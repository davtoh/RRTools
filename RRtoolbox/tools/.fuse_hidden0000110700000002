# -*- coding: utf-8 -*-
__author__ = 'Davtoh'

from RRtoolbox.lib.arrayops import filterFactory, biggestCnt, spoint2opointfunc, brightness, thresh_biggestCnt
from RRtoolbox.lib.plotter import fastplt
import cv2
import numpy as np

def getLensCountour(thresh):
    """
    find biggest area and contour
    :param thresh:
    :return:
    """
    contours,hierarchy = cv2.findContours(thresh,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)
    return biggestCnt(contours)

def drawEllipse(maks,cnt,val=0):
    """
    project ellipse over mask
    :param maks:
    :param cnt:
    :param val:
    :return:
    """
    ellipse = cv2.fitEllipse(cnt) # get ellipse
    cv2.ellipse(maks,ellipse,val,-1) # project ellipse over mask
    return maks

def drawCircle(mask,cnt,val=0):
    """
    project circle over mask
    :param mask:
    :param cnt:
    :param val:
    :return:
    """
    center, radius = cv2.minEnclosingCircle(cnt)
    cv2.circle(mask, tuple(map(int,center)), int(radius), val,-1) # project lens over mask
    return mask

def ellipseLens(img, mask, color = 0):
    """
    Place lens-like object in image.

    :param img: image to place lens
    :param color: color of the lens
    :return: image with simulated lens
    """
    # scaling operation
    sz = img.shape[:2] # get original image size
    pshape = mask.shape
    if sz != pshape:
        # make rescaling function: scaled point -to- original point function
        scalepoints = spoint2opointfunc(pshape,sz)
    else:
        scalepoints = lambda x: x # return the same points
    # find biggest area and contour
    cnt = thresh_biggestCnt(mask)
    # rescale contour to original image contour
    cnt2 = np.int32(scalepoints(cnt))
    # get ellipse for original image to simulate lens
    ellipse = cv2.fitEllipse(cnt2)
    # get circle for original image to simulate lens
    circle = cv2.minEnclosingCircle(cnt2)
    mask_lens = np.ones(sz,dtype=np.uint8) # create mask
    cv2.ellipse(mask_lens,ellipse,0,-1) # project lens over mask
    # simulate lens
    img[mask_lens>0] = color # use mask to project black color over original image
    return img, mask_lens

def circleLens(img, cnt, color = 0):
    pass

def simulateLens(img, pshape = (300, 300), parameters = (10, 30, None), color = 0):
    """
    Place lens-like object in image.

    :param img: image to place lens
    :param pshape: shape to resize processing image to increase performance
    :param parameters: for internal process used to filter image when getting brightness
    :param color: color of the lens
    :return: image with simulated lens
    """
    # scaling operation
    scaled_img = cv2.resize(img, pshape) # resize to scaled image
    fore2 = scaled_img.copy()

    if parameters is not None:
        myfilter = filterFactory(*parameters) # alfa,beta1,beta2
        fore2=myfilter(fore2.astype("float"))*255#*fore.astype("float")
        fore2 = fore2.astype("uint8")

    P = brightness(fore2) # get scaled image brightness
    thresh,sure_bg = cv2.threshold(P,0,1,cv2.THRESH_BINARY+cv2.THRESH_OTSU) # obtain over threshold
    thresh,sure_fg = cv2.threshold(P,thresh+10,1,cv2.THRESH_BINARY)

    markers = np.ones_like(sure_fg).astype("int32") # make background markers
    markers[sure_bg==1]=0 # mark unknown markers
    markers[sure_fg==1]=2 # mark sure object markers

    cv2.watershed(scaled_img,markers) # get watershed on markers

    thresh,lastthresh = cv2.threshold(markers.astype("uint8"),1,1,cv2.THRESH_BINARY) # get binary image of contour

    return ellipseLens(img,lastthresh,color)

def demo():
    pass

if __name__ == "__main__":
    pass