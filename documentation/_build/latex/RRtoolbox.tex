% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}

\usepackage{babel}
\usepackage{times}
\usepackage[Sonny]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig. }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }



\title{RRtoolbox Documentation}
\date{July 07, 2016}
\release{1}
\author{davtoh}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\setcounter{tocdepth}{3}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{RRtoolbox package}
\label{RRtoolbox::doc}\label{RRtoolbox:welcome-to-rrtoolbox-s-documentation}\label{RRtoolbox:rrtoolbox-package}

\section{Subpackages}
\label{RRtoolbox:subpackages}

\subsection{RRtoolbox.lib package}
\label{RRtoolbox.lib:rrtoolbox-lib-package}\label{RRtoolbox.lib::doc}

\subsubsection{Subpackages}
\label{RRtoolbox.lib:subpackages}

\paragraph{RRtoolbox.lib.arrayops package}
\label{RRtoolbox.lib.arrayops:rrtoolbox-lib-arrayops-package}\label{RRtoolbox.lib.arrayops::doc}

\subparagraph{Submodules}
\label{RRtoolbox.lib.arrayops:submodules}

\subparagraph{RRtoolbox.lib.arrayops.basic module}
\label{RRtoolbox.lib.arrayops:rrtoolbox-lib-arrayops-basic-module}\label{RRtoolbox.lib.arrayops:module-RRtoolbox.lib.arrayops.basic}\index{RRtoolbox.lib.arrayops.basic (module)}
This module contains simple array operation methods
\index{angle() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.angle}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{angle}}{\emph{v1}, \emph{v2}, \emph{deg=False}}{}
Angle between two N dimmensional vectors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{v1}} -- vector 1.

\item {} 
\textbf{\texttt{v2}} -- vector 2.

\item {} 
\textbf{\texttt{deg}} -- if True angle is in Degrees, else radians.

\end{itemize}

\item[{Returns}] \leavevmode
angle in radians.

\end{description}\end{quote}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{angle\PYGZus{}between}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{1.5707963267948966}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{angle\PYGZus{}between}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{0.0}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{angle\PYGZus{}between}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{3.141592653589793}
\end{Verbatim}

\begin{notice}{note}{Note:}
obtained from \href{http://stackoverflow.com/a/13849249/5288758}{http://stackoverflow.com/a/13849249/5288758}
and tested in \href{http://onlinemschool.com/math/assistance/vector/angl/}{http://onlinemschool.com/math/assistance/vector/angl/}
\end{notice}

\end{fulllineitems}

\index{angle2D() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.angle2D}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{angle2D}}{\emph{v1}, \emph{v2}, \emph{deg=False}, \emph{absolute=None}}{}
Angle between two 2 dimensional vectors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{v1}} -- vector 1.

\item {} 
\textbf{\texttt{v2}} -- vector 2.

\item {} 
\textbf{\texttt{deg}} -- if True angle is in Degrees, else radians.

\item {} 
\textbf{\texttt{absolute}} -- if None returns the angle (0 yo 180(pi)) between v1 and v2.
if True returns the absolute angle (0 to 360(2pi)) from v1 as axis to v2.
if False returns the angle (0 to 180 or 0 to -180) from v1 as axis to v2,
where v2 angle relative to v1 is positive or negative if counter-clock or clock wise.

\end{itemize}

\item[{Returns}] \leavevmode
angle in radians.

\end{description}\end{quote}

\begin{notice}{note}{Note:}
implemented according to \href{http://math.stackexchange.com/a/747992}{http://math.stackexchange.com/a/747992}
and tested in \href{http://onlinemschool.com/math/assistance/vector/angl/}{http://onlinemschool.com/math/assistance/vector/angl/}
\end{notice}

\end{fulllineitems}

\index{angleXY() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.angleXY}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{angleXY}}{\emph{coorX}, \emph{coorY}, \emph{angle}}{}
Rotate coordinate.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{coorX}} -- x coordinate.

\item {} 
\textbf{\texttt{coorY}} -- y coordinate.

\item {} 
\textbf{\texttt{angle}} -- radian angle.

\end{itemize}

\item[{Returns}] \leavevmode
rotated x,y

\end{description}\end{quote}

\end{fulllineitems}

\index{anorm() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.anorm}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{anorm}}{\emph{a}}{}
norm in array.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{a}} -- 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{anorm2() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.anorm2}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{anorm2}}{\emph{a}}{}
Summation of squares (helper function for {\hyperref[RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.anorm]{\emph{\code{anorm()}}}})
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{a}} -- 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{axesIntercept() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.axesIntercept}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{axesIntercept}}{\emph{coorSM}, \emph{maxS}, \emph{maxM}}{}
Intercept static axis (S) and mobile axis (M) with a coordinate connecting
both axes from minS to minM.
\begin{quote}
\begin{quote}

S1                     S2
\end{quote}

S0 {\color{red}\bfseries{}\textbar{}\textless{}---------------------\textbar{}}-----------\textgreater{} maxS
\end{quote}
\begin{description}
\item[{coorSM \textless{}---------\textbar{}                      \textbar{}}] \leavevmode\begin{quote}

M1                     M2
\end{quote}

M0 \textless{}---------{\color{red}\bfseries{}\textbar{}---------------------\textgreater{}\textbar{}} maxM

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{coorSM}} -- coordinate of vector from S=0 to M=0.

\item {} 
\textbf{\texttt{maxS}} -- value representing end of estatic axis.

\item {} 
\textbf{\texttt{maxM}} -- value representing end of mobile axis.

\end{itemize}

\item[{Returns}] \leavevmode
S1,S2,M1,M2.

\end{description}\end{quote}

\end{fulllineitems}

\index{boxPads() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.boxPads}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{boxPads}}{\emph{bx}, \emph{points}}{}
Get box pads to fit all.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{bx}} -- box coordinates or previous boxPads {[}left\_top, right\_bottom{]}

\item {} 
\textbf{\texttt{points}} -- array of points

\end{itemize}

\item[{Returns}] \leavevmode
{[}(left,top),(right,bottom){]} where bx and points fit.

\end{description}\end{quote}

\end{fulllineitems}

\index{centerM() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.centerM}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{centerM}}{\emph{coor}, \emph{maxM}}{}
Center vector coor in M axis.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{coor}} -- coordinate of vector from S=0 to M center

\item {} 
\textbf{\texttt{maxM}} -- value representing end of mobile axis

\end{itemize}

\item[{Returns}] \leavevmode
M centered coordinate

\end{description}\end{quote}

\end{fulllineitems}

\index{centerS() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.centerS}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{centerS}}{\emph{coor}, \emph{maxS}}{}
Center vector coor in S axis.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{coor}} -- coordinate of vector from S center to M=0

\item {} 
\textbf{\texttt{maxS}} -- value representing end of estatic axis

\end{itemize}

\item[{Returns}] \leavevmode
S centered coordinate

\end{description}\end{quote}

\end{fulllineitems}

\index{centerSM() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.centerSM}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{centerSM}}{\emph{coorSM}, \emph{maxS}, \emph{maxM}}{}
Center vector coorSM in both S and M axes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{coorSM}} -- coordinate of vector from S to M centers.

\item {} 
\textbf{\texttt{maxS}} -- value representing end of estatic axis.

\item {} 
\textbf{\texttt{maxM}} -- value representing end of mobile axis.

\end{itemize}

\item[{Returns}] \leavevmode
SM centered coordinate.

\end{description}\end{quote}

\end{fulllineitems}

\index{contours2mask() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.contours2mask}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{contours2mask}}{\emph{contours}, \emph{shape=None}, \emph{astype=\textless{}type `bool'\textgreater{}}}{}
Creates an array with filled polygons formed by contours.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{contours}} -- list of contour or points forming objects

\item {} 
\textbf{\texttt{shape}} -- (None) shape of array. If None it creates an array fitted to contours.

\item {} 
\textbf{\texttt{astype}} -- (``bool'') numpy type

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{contoursArea() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.contoursArea}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{contoursArea}}{\emph{contours}}{}
Accumulates areas from list of contours.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{contours}} -- list of contours or binary array.

\item[{Returns}] \leavevmode
area.

\end{description}\end{quote}

\end{fulllineitems}

\index{convertXY() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.convertXY}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{convertXY}}{\emph{x}, \emph{y}, \emph{backshape}, \emph{foreshape}, \emph{flag=0}, \emph{quartile=0}, \emph{angle=None}}{}
Convert absolute XY 0,0 coordinates to new system WZ.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{x}} -- x coordinate.

\item {} 
\textbf{\texttt{y}} -- y coordinate.

\item {} 
\textbf{\texttt{backshape}} -- shape of background image.

\end{itemize}

\end{description}\end{quote}

:param foreshape:shape of foreground image.
:param flag: flag for position (default=0).
\begin{itemize}
\item {} 
flag==0 : foreground to left up.

\item {} 
flag==1 : foreground to left down.

\item {} 
flag==2 : foreground to right up.

\item {} 
flag==3 : foreground to right down.

\item {} 
flag==4 : foreground at center of background.

\item {} 
flag==5 : XY 0,0 is at center of background.

\item {} 
flag==6 : XY 0,0 is at center of foreground.

\item {} 
flag==7 : XY 0,0 is at right down of foreground.

\end{itemize}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{quartile}} -- place Mobile image at quartile 1,2,3,4.
if left quartile=0 image won't be moved.

\item {} 
\textbf{\texttt{angle}} -- angle in radians (defalut=None). if None it does not apply.

\end{itemize}

\item[{Returns}] \leavevmode
W,Z

\end{description}\end{quote}

\end{fulllineitems}

\index{convexityRatio() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.convexityRatio}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{convexityRatio}}{\emph{cnt}, \emph{hull=None}}{}
Ratio to test if contours are irregular
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{cnt}} -- contour

\end{description}\end{quote}

:param hull:(None) convex hull
:return: ratio

\end{fulllineitems}

\index{entroyTest() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.entroyTest}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{entroyTest}}{\emph{arr}}{}
Entropy test of intensity arrays. (Helper function for \code{entropy()})
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{arr}} -- array MxN of dim 2.

\item[{Returns}] \leavevmode
entropy.

\end{description}\end{quote}

\end{fulllineitems}

\index{find\_near() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.find_near}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{find\_near}}{\emph{m}, \emph{thresh=None}, \emph{side=None}}{}
helper function for findminima and findmaxima
:param m: minima or maxima points
:param thresh: guess or seed point
:param side: left or right
:return: value

\end{fulllineitems}

\index{findmaxima() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.findmaxima}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{findmaxima}}{\emph{hist}, \emph{thresh=None}, \emph{side=None}}{}
Get nearest peak value to a thresh point from a histogram.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{hist}} -- histogram

\item {} 
\textbf{\texttt{thresh}} -- initial seed

\item {} 
\textbf{\texttt{side}} -- find valley from left or right of thresh

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{findminima() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.findminima}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{findminima}}{\emph{hist}, \emph{thresh=None}, \emph{side=None}}{}
Get nearest valley value to a thresh point from a histogram.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{hist}} -- histogram

\item {} 
\textbf{\texttt{thresh}} -- initial seed

\item {} 
\textbf{\texttt{side}} -- find valley from left or right of thresh

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{getOtsuThresh() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.getOtsuThresh}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{getOtsuThresh}}{\emph{hist}}{}
From histogram calculate Otsu threshold value.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{hist}} -- histogram

\item[{Returns}] \leavevmode
otsu threshold value

\end{description}\end{quote}

\end{fulllineitems}

\index{getTransformedCorners() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.getTransformedCorners}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{getTransformedCorners}}{\emph{shape}, \emph{H}}{}
from shape gets transformed corners of array.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{shape}} -- H,W array shape

\item {} 
\textbf{\texttt{H}} -- transformation matrix

\end{itemize}

\item[{Returns}] \leavevmode
upper\_left, upper\_right, lower\_right, lower\_lef transformed corners.

\end{description}\end{quote}

\end{fulllineitems}

\index{getTransparency() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.getTransparency}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{getTransparency}}{\emph{array}}{}
Convert foreground to background.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{array}} -- image array.

\item[{Returns}] \leavevmode
alfa (int or array)

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_x\_space() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.get_x_space}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{get\_x\_space}}{\emph{funcs}, \emph{step=10}, \emph{xleft=-300}, \emph{xright=300}}{}
get X axis space by brute force. This can be used to find the x points
where the points in the y axis of any number of functions become stable.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{funcs}} -- list of functions

\item {} 
\textbf{\texttt{step}} -- \begin{enumerate}
\setcounter{enumi}{9}
\item {} 
step to close guess to maximum

\end{enumerate}


\item {} 
\textbf{\texttt{xleft}} -- maximum left limit

\item {} 
\textbf{\texttt{xright}} -- maximum right limit

\end{itemize}

\item[{Returns}] \leavevmode
linspace

\end{description}\end{quote}

\end{fulllineitems}

\index{getdataVH() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.getdataVH}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{getdataVH}}{\emph{array}, \emph{ypad=0}, \emph{xpad=0}, \emph{bgrcolor=None}, \emph{alfa=None}}{}
Get data from array according to padding (Helper function for {\hyperref[RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.padVH]{\emph{\code{padVH()}}}}).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{array}} -- list of arrays to get data

\item {} 
\textbf{\texttt{ypad}} -- how much to pad in y axis

\item {} 
\textbf{\texttt{xpad}} -- how much to pad in x axis

\end{itemize}

\item[{Returns}] \leavevmode
matrix\_shapes, grid\_div, row\_grid, row\_gridpad, globalgrid

\end{description}\end{quote}

\end{fulllineitems}

\index{histogram() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.histogram}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{histogram}}{\emph{img}}{}
Get image histogram.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{img}} -- gray or image with any bands

\item[{Returns}] \leavevmode
histogram of every band

\end{description}\end{quote}

\end{fulllineitems}

\index{im2imFormat() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.im2imFormat}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{im2imFormat}}{\emph{src}, \emph{dst}}{}
Tries to convert source image to destine image format.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{src}} -- source image.

\item {} 
\textbf{\texttt{dst}} -- destine image.

\end{itemize}

\item[{Returns}] \leavevmode
reshaped source image.

\end{description}\end{quote}

\end{fulllineitems}

\index{im2shapeFormat() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.im2shapeFormat}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{im2shapeFormat}}{\emph{im}, \emph{shape}}{}
Tries to convert image to intuited format from shape.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{im}} -- image.

\item {} 
\textbf{\texttt{shape}} -- 
shape to get format.

shapes:
* (None, None): converts to gray
* (None, None, 2): converts to GR555
* (None, None, 3): converts to BGR
* (None, None, 4): converts to BGRA


\end{itemize}

\item[{Returns}] \leavevmode
reshaped image.

\end{description}\end{quote}

\end{fulllineitems}

\index{instability\_bf() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.instability_bf}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{instability\_bf}}{\emph{funcs}, \emph{step=10}, \emph{maximum=300}, \emph{guess=0}, \emph{tolerance=0.01}}{}
Find the instability of function approaching value by brute force,
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{funcs}} -- list of functions

\item {} 
\textbf{\texttt{step}} -- \begin{enumerate}
\setcounter{enumi}{9}
\item {} 
step to close guess to maximum

\end{enumerate}


\item {} 
\textbf{\texttt{maximum}} -- \begin{enumerate}
\setcounter{enumi}{299}
\item {} 
maximum value, if guess surpass this value then calculations are stopped.

\end{enumerate}


\item {} 
\textbf{\texttt{guess}} -- \begin{enumerate}
\setcounter{enumi}{-1}
\item {} 
initial guess

\end{enumerate}


\item {} 
\textbf{\texttt{tolerance}} -- (0.01) tolerance with last step to check instability.

\end{itemize}

\item[{Returns}] \leavevmode
(state, updated guess). state is True if successful, else False.

\end{description}\end{quote}

\end{fulllineitems}

\index{invertM() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.invertM}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{invertM}}{\emph{coorSM}, \emph{maxM}}{}
Invert M axis.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{coorSM}} -- coordinate of vector for M inverted axes.

\item {} 
\textbf{\texttt{maxS}} -- value representing end of estatic axis.

\item {} 
\textbf{\texttt{maxM}} -- value representing end of mobile axis.

\end{itemize}

\item[{Returns}] \leavevmode
SM coordinate on S axis and inverted M axis.

\end{description}\end{quote}

\end{fulllineitems}

\index{invertSM() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.invertSM}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{invertSM}}{\emph{coorSM}, \emph{maxS}, \emph{maxM}}{}
Invert S and M axes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{coorSM}} -- coordinate of vector for SM inverted axes.

\item {} 
\textbf{\texttt{maxS}} -- value representing end of estatic axis.

\item {} 
\textbf{\texttt{maxM}} -- value representing end of mobile axis.

\end{itemize}

\item[{Returns}] \leavevmode
SM coordinate on inverted SM axes.

\end{description}\end{quote}

\end{fulllineitems}

\index{isnumpy() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.isnumpy}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{isnumpy}}{\emph{arr}}{}
Test whether an object is a numpy array.
:param arr:
:return: True if numpy array, else false.

\end{fulllineitems}

\index{makeVis() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.makeVis}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{makeVis}}{\emph{globalgrid}, \emph{bgrcolor=None}}{}
Make visualization (Helper function for {\hyperref[RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.padVH]{\emph{\code{padVH()}}}})
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{globalgrid}} -- shape

\item {} 
\textbf{\texttt{bgrcolor}} -- color of visualization

\end{itemize}

\item[{Returns}] \leavevmode
array of shape globalgrid

\end{description}\end{quote}

\end{fulllineitems}

\index{matrixIntercept() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.matrixIntercept}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{matrixIntercept}}{\emph{x}, \emph{y}, \emph{staticm}, \emph{*mobilem}}{}
Intercepts planes x and y of a static matrix (staticm) with N mobile matrices (mobilem)
translated from the origin to x,y coordinates.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{x}} -- x coordinate.

\item {} 
\textbf{\texttt{y}} -- y coordinate.

\item {} 
\textbf{\texttt{staticm}} -- static matrix.

\item {} 
\textbf{\texttt{mobilem}} -- mobile matrices.

\end{itemize}

\item[{Returns}] \leavevmode
ROI of intercepted matrices {[}staticm,*mobilem{]}.

\end{description}\end{quote}

\end{fulllineitems}

\index{multiple\_superpose() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.multiple_superpose}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{multiple\_superpose}}{\emph{base}, \emph{fore}, \emph{H}, \emph{foremask=None}}{}
Superpose multiple foreground images to a single base image.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{base}} -- backgraound, base or dipest level image (level -1)

\item {} 
\textbf{\texttt{fore}} -- foreground image list (in order of level i = 0, ... , N)

\item {} 
\textbf{\texttt{H}} -- transformation matrix of fore in level i to overlay in base

\item {} 
\textbf{\texttt{foremask}} -- foreground alfa mask in level i

\end{itemize}

\item[{Returns}] \leavevmode
generator of each overlay

\end{description}\end{quote}

\end{fulllineitems}

\index{noisy() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.noisy}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{noisy}}{\emph{arr}, \emph{mode}}{}
Add noise to arrays
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{arr}} -- Input ndarray data (it will be converted to float).

\item {} 
\textbf{\texttt{mode}} -- 
noise method:
\begin{itemize}
\item {} 
`gauss' - Gaussian-distributed additive noise.

\item {} 
`poisson' - Poisson-distributed noise generated from the data.

\item {} 
`s\&p' - Replaces random pixels with 0 or 1.

\item {} \begin{description}
\item[{`speckle' - Multiplicative noise using out = arr + n*arr,where}] \leavevmode
n is uniform noise with specified mean \& variance.

\end{description}

\end{itemize}


\end{itemize}

\end{description}\end{quote}

:return noisy arr

\end{fulllineitems}

\index{normalize() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.normalize}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{normalize}}{\emph{arr}}{}
Normalize array to ensure range {[}0,1{]}

\end{fulllineitems}

\index{normalize2() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.normalize2}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{normalize2}}{\emph{arr}}{}
Normalize with factor of absolute maximum value.

\end{fulllineitems}

\index{normalizeCustom() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.normalizeCustom}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{normalizeCustom}}{\emph{arr}, \emph{by=\textless{}function amax\textgreater{}}, \emph{axis=None}}{}
Normalize array with custom operations.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{arr}} -- array (it does not correct negative values, use preferable NxM).

\item {} 
\textbf{\texttt{by}} -- np,max, np.sum or any function that gets an array to obtain factor.

\item {} 
\textbf{\texttt{axis}} -- if None it normalizes in all axes else in the selected axis.

\end{itemize}

\item[{Returns}] \leavevmode
normalized to with factor.

\end{description}\end{quote}

\end{fulllineitems}

\index{overlay() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.overlay}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{overlay}}{\emph{back}, \emph{fore}, \emph{alpha=None}, \emph{alfainverted=False}, \emph{under=False}, \emph{flag=0}}{}
Try to Overlay any dimension array.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{back}} -- BGRA background image.

\item {} 
\textbf{\texttt{fore}} -- BGRA foreground image.

\item {} 
\textbf{\texttt{alpha}} -- transparency channel.

\item {} 
\textbf{\texttt{alfainverted}} -- if True inverts alpha transparency.

\item {} 
\textbf{\texttt{under}} -- if True, place back as fore and fore as back.

\item {} 
\textbf{\texttt{flag}} -- 
(experimental)
\begin{enumerate}
\setcounter{enumi}{-1}
\item {} \begin{description}
\item[{Normally replace inverted transparency of alpha in back (N);}] \leavevmode
superpose alpha in back (V).

\end{description}

\item {} \begin{description}
\item[{Bloat and replace inverted transparency of alpha in back;}] \leavevmode
superpose bgr in back (V).

\end{description}

\item {} 
Superpose inverted transparent COLOR of alpha in back.

\item {} 
Superpose inverted transparent COLOR of alpha in back.

\item {} \begin{description}
\item[{Superpose transparent of alpha in back;}] \leavevmode
superpose transparent COLOR of alpha in back.

\end{description}

\item {} \begin{description}
\item[{Superpose transparent of alpha in back;}] \leavevmode
superpose transparent COLOR of alpha in back.

\end{description}

\end{enumerate}


\end{itemize}

\item[{Returns}] \leavevmode
overlayed array

\end{description}\end{quote}


\strong{See also:}


{\hyperref[RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.overlay2]{\emph{\code{overlay2()}}}}



\end{fulllineitems}

\index{overlay2() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.overlay2}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{overlay2}}{\emph{back}, \emph{fore}}{}
Overlay foreground to x,y coordinates in background image.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{back}} -- background image (numpy array dim 3).

\item {} 
\textbf{\texttt{fore}} -- foreground image (numpy array dim 4). the fourth
dimension is used for transparency.

\end{itemize}

\item[{Returns}] \leavevmode
back (with overlay).

\end{description}\end{quote}

\#Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{cv2}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{time}
\PYG{n}{a}\PYG{o}{=} \PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{back} \PYG{o}{=} \PYG{n}{cv2}\PYG{o}{.}\PYG{n}{imread}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{t1.jpg}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{temp} \PYG{o}{=} \PYG{n}{back}\PYG{o}{.}\PYG{n}{shape}
\PYG{n}{bgr} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{temp}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{temp}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{uint8}\PYG{p}{)}
\PYG{n}{points} \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{86}\PYG{p}{,} \PYG{l+m+mi}{162}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1219}\PYG{p}{,} \PYG{l+m+mi}{1112}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{2219}\PYG{p}{,} \PYG{l+m+mi}{2112}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1277}\PYG{p}{,}\PYG{l+m+mi}{3000}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+m+mi}{86}\PYG{p}{,} \PYG{l+m+mi}{162}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{col\PYGZus{}in} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{255}\PYG{p}{)}
\PYG{n}{thickness} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{points}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{pt1} \PYG{o}{=} \PYG{p}{(}\PYG{n}{points}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{points}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{pt2} \PYG{o}{=} \PYG{p}{(}\PYG{n}{points}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{points}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{cv2}\PYG{o}{.}\PYG{n}{line}\PYG{p}{(}\PYG{n}{bgr}\PYG{p}{,} \PYG{n}{pt1}\PYG{p}{,} \PYG{n}{pt2}\PYG{p}{,} \PYG{n}{col\PYGZus{}in}\PYG{p}{,} \PYG{n}{thickness}\PYG{p}{)}

\PYG{n}{overlay}\PYG{p}{(}\PYG{n}{back}\PYG{p}{,}\PYG{n}{bgr}\PYG{p}{)}

\PYG{n}{win} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{overlay}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{cv2}\PYG{o}{.}\PYG{n}{namedWindow}\PYG{p}{(}\PYG{n}{win}\PYG{p}{,}\PYG{n}{cv2}\PYG{o}{.}\PYG{n}{WINDOW\PYGZus{}NORMAL}\PYG{p}{)}
\PYG{n}{cv2}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{win}\PYG{p}{,} \PYG{n}{back}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{a}
\PYG{n}{cv2}\PYG{o}{.}\PYG{n}{waitKey}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{cv2}\PYG{o}{.}\PYG{n}{destroyAllWindows}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}


\strong{See also:}


{\hyperref[RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.overlay]{\emph{\code{overlay()}}}}



\end{fulllineitems}

\index{overlayXY() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.overlayXY}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{overlayXY}}{\emph{x}, \emph{y}, \emph{back}, \emph{fore}, \emph{alfa=None}, \emph{alfainverted=False}, \emph{under=False}, \emph{flag=0}}{}
Overlay foreground image to x,y coordinates in background image.
This function support images of different sizes with formats: BGR background
and BGRA foreground of Opencv or numpy images.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{x}} -- x position in background.

\item {} 
\textbf{\texttt{y}} -- y position in background.

\item {} 
\textbf{\texttt{back}} -- background image (numpy array dim 3).

\item {} 
\textbf{\texttt{fore}} -- foreground image (numpy array dim 4). the fourth
dimension is used for transparency.

\end{itemize}

\item[{Returns}] \leavevmode
back (with overlay)

\end{description}\end{quote}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{cv2}
\PYG{n}{back} \PYG{o}{=} \PYG{n}{cv2}\PYG{o}{.}\PYG{n}{imread}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{t1.jpg}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{bgr} \PYG{o}{=} \PYG{n}{cv2}\PYG{o}{.}\PYG{n}{imread}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mustache.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{o}{=}\PYG{n}{convertXY}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{back}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{,}\PYG{n}{bgr}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{,}\PYG{n}{flag}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{overlayXY}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{back}\PYG{p}{,}\PYG{n}{bgr}\PYG{p}{)}
\PYG{n}{win} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{overlay}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{cv2}\PYG{o}{.}\PYG{n}{namedWindow}\PYG{p}{(}\PYG{n}{win}\PYG{p}{,}\PYG{n}{cv2}\PYG{o}{.}\PYG{n}{WINDOW\PYGZus{}NORMAL}\PYG{p}{)}
\PYG{n}{cv2}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{win}\PYG{p}{,} \PYG{n}{back}\PYG{p}{)}
\PYG{n}{cv2}\PYG{o}{.}\PYG{n}{waitKey}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{cv2}\PYG{o}{.}\PYG{n}{destroyAllWindows}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{overlaypng() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.overlaypng}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{overlaypng}}{\emph{back}, \emph{fore}, \emph{alpha=None}, \emph{alfainverted=False}, \emph{under=False}, \emph{flag=0}}{}
Overlay only BGRA.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{back}} -- BGRA background image.

\item {} 
\textbf{\texttt{fore}} -- BGRA foreground image.

\item {} 
\textbf{\texttt{alpha}} -- transparency channel.

\item {} 
\textbf{\texttt{alfainverted}} -- if True inverts alpha transparency.

\item {} 
\textbf{\texttt{under}} -- if True, place back as fore and fore as back.

\item {} 
\textbf{\texttt{flag}} -- 
(experimental)
\begin{enumerate}
\setcounter{enumi}{-1}
\item {} \begin{description}
\item[{Normally replace inverted transparency of alpha in back (N);}] \leavevmode
superpose alpha in back (V).

\end{description}

\item {} \begin{description}
\item[{Bloat and replace inverted transparency of alpha in back;}] \leavevmode
superpose bgr in back (V).

\end{description}

\item {} 
Superpose inverted transparent COLOR of alpha in back.

\item {} 
Superpose inverted transparent COLOR of alpha in back.

\item {} \begin{description}
\item[{Superpose transparent of alpha in back;}] \leavevmode
superpose transparent COLOR of alpha in back.

\end{description}

\item {} \begin{description}
\item[{Superpose transparent of alpha in back;}] \leavevmode
superpose transparent COLOR of alpha in back.

\end{description}

\end{enumerate}


\end{itemize}

\item[{Returns}] \leavevmode
overlayed array

\end{description}\end{quote}


\strong{See also:}


{\hyperref[RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.overlay]{\emph{\code{overlay()}}}}, {\hyperref[RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.overlay2]{\emph{\code{overlay2()}}}}



\end{fulllineitems}

\index{padVH() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.padVH}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{padVH}}{\emph{imgs}, \emph{ypad=0}, \emph{xpad=0}, \emph{bgrcolor=None}, \emph{alfa=None}}{}
Pad Vertically and Horizontally image or group of images into an array.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{imgs}} -- image to pad or list of horizontal images (i.e. piled
up horizontally as {[}V1,..,VN{]} where each can be a list
of vertical piling VN = {[}H1,..,HM{]}. It can be successive
like horizontals, verticals, horizontals, etc.

\item {} 
\textbf{\texttt{ypad}} -- padding in axis y

\item {} 
\textbf{\texttt{xpad}} -- padding in axis x

\item {} 
\textbf{\texttt{bgrcolor}} -- color of spaces

\item {} 
\textbf{\texttt{alfa}} -- transparency of imgs over background of bgrcolor color.

\end{itemize}

\item[{Returns}] \leavevmode
visualization of paded and piled images in imgs.

\end{description}\end{quote}

\end{fulllineitems}

\index{pad\_to\_fit\_H() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.pad_to_fit_H}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{pad\_to\_fit\_H}}{\emph{shape1}, \emph{shape2}, \emph{H}}{}
get boxPads to fit transformed shape1 in shape2.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{shape1}} -- shape of array 1

\item {} 
\textbf{\texttt{shape2}} -- shape of array 2

\item {} 
\textbf{\texttt{H}} -- transformation matrix to use in shape1

\end{itemize}

\item[{Returns}] \leavevmode
{[}(left,top),(right,bottom){]}

\end{description}\end{quote}

\end{fulllineitems}

\index{points2mask() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.points2mask}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{points2mask}}{\emph{pts}, \emph{shape=None}, \emph{astype=\textless{}type `bool'\textgreater{}}}{}
Creates an array with the filled polygon formed by points.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{pts}} -- points.

\item {} 
\textbf{\texttt{shape}} -- (None) shape of array. If None it creates an array fitted to points.

\item {} 
\textbf{\texttt{astype}} -- (``bool'') numpy type

\end{itemize}

\item[{Returns}] \leavevmode
array.

\end{description}\end{quote}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{pts} \PYG{o}{=} \PYG{n}{random\PYGZus{}points}\PYG{p}{(}\PYG{p}{[}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{img} \PYG{o}{=} \PYG{n}{points2mask}\PYG{p}{(}\PYG{n}{pts}\PYG{p}{)}
\PYG{n}{plotim}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{filled}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{img}\PYG{p}{)}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{points\_generator() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.points_generator}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{points\_generator}}{\emph{shape=(10}, \emph{10)}, \emph{nopoints=None}, \emph{convex=False}, \emph{erratic=False}, \emph{complete=False}}{}
generate points.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{shape}} -- enclosed frame

\item {} 
\textbf{\texttt{nopoints}} -- number of points

\item {} 
\textbf{\texttt{convex}} -- if True make points convex,
else points follow a circular pattern.

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{polygonArea() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.polygonArea}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{polygonArea}}{\emph{pts}}{}
Area of points calculating polygon Area.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{pts}} -- points.

\item[{Returns}] \leavevmode
area value.

\end{description}\end{quote}
\begin{description}
\item[{..note::}] \leavevmode\begin{itemize}
\item {} 
If polygon is incomplete (last is not first point) it completes the array.

\item {} 
If the polygon crosses over itself the algorithm will fail.

\item {} 
Based on \href{http://www.mathopenref.com/coordpolygonarea.html}{http://www.mathopenref.com/coordpolygonarea.html}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{polygonArea\_calcule() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.polygonArea_calcule}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{polygonArea\_calcule}}{\emph{pts}}{}
Area of points calculating polygon Area.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{pts}} -- points.

\item[{Returns}] \leavevmode
area value.

\end{description}\end{quote}
\begin{description}
\item[{..note::}] \leavevmode\begin{itemize}
\item {} 
If polygon is incomplete (last is not first point) it completes the array.

\item {} 
If the polygon crosses over itself the algorithm will fail.

\item {} 
Based on \href{http://www.mathopenref.com/coordpolygonarea.html}{http://www.mathopenref.com/coordpolygonarea.html}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{polygonArea\_contour() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.polygonArea_contour}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{polygonArea\_contour}}{\emph{pts}}{}
Area of points using contours.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{pts}} -- points.

\item[{Returns}] \leavevmode
area value.

\end{description}\end{quote}

..note:: if polygon is incomplete (last is not first point) it completes the array.

\end{fulllineitems}

\index{polygonArea\_fill() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.polygonArea_fill}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{polygonArea\_fill}}{\emph{pts}}{}
Area of points using filled polygon and pixel count.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{pts}} -- points.

\item[{Returns}] \leavevmode
area value.

\end{description}\end{quote}

..note:: if polygon is incomplete (last is not first point) it completes the array.

\end{fulllineitems}

\index{process\_as\_blocks() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.process_as_blocks}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{process\_as\_blocks}}{\emph{arr}, \emph{func}, \emph{block\_shape=(3}, \emph{3)}, \emph{mask=None}, \emph{asWindows=False}}{}
process with function over an array using blocks (using re-striding).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{arr}} -- array to process

\item {} 
\textbf{\texttt{func}} -- function to feed blocks

\item {} 
\textbf{\texttt{block\_shape}} -- (3,3) shape of blocks

\item {} 
\textbf{\texttt{mask}} -- (None) mask to process arr

\item {} 
\textbf{\texttt{asWindows}} -- (False) if True all blocks overlap each other to give
a result for each position of arr, if False the results are
given in blocks equivalent for each processed blocks of arr (faster).

\end{itemize}

\item[{Returns}] \leavevmode
processed array.

\end{description}\end{quote}

\end{fulllineitems}

\index{quadrant() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.quadrant}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{quadrant}}{\emph{coorX}, \emph{coorY}, \emph{maxX}, \emph{maxY}, \emph{quadrant=0}}{}
Moves a point to a quadrant
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{coorX}} -- point in x coordinate

\item {} 
\textbf{\texttt{coorY}} -- point in y coordinate

\item {} 
\textbf{\texttt{maxX}} -- max value in x axis

\item {} 
\textbf{\texttt{maxY}} -- max value in y axis

\item {} 
\textbf{\texttt{quadrant}} -- Cartesian quadrant, if 0 or False it leaves coorX and coorY unprocessed.

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{random\_points() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.random_points}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{random\_points}}{\emph{axes\_range=((-50}, \emph{50)}, \emph{)}, \emph{nopoints=4}, \emph{complete=False}}{}
Get random points.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{axes\_range}} -- {[}x\_points\_range, y\_points\_range{]} where points\_range is (min,max) range in axis.

\item {} 
\textbf{\texttt{nopoints}} -- number of points.

\item {} 
\textbf{\texttt{complete}} -- last point is the first point (adds an additional point i.e. nopoints+1).

\end{itemize}

\item[{Returns}] \leavevmode
numpy array.

\end{description}\end{quote}

\end{fulllineitems}

\index{recursiveMap() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.recursiveMap}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{recursiveMap}}{\emph{function}, \emph{sequence}}{}
Iterate recursively over a structure using a function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{function}} -- function to apply

\item {} 
\textbf{\texttt{sequence}} -- iterator

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{relativeQuadrants() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.relativeQuadrants}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{relativeQuadrants}}{\emph{points}}{}
Get quadrants of relative vectors obtained from points.
:param points: array of points.
:return: quadrants.

\end{fulllineitems}

\index{relativeVectors() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.relativeVectors}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{relativeVectors}}{\emph{pts}, \emph{all=True}}{}
Form vectors from points.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{pts}} -- array of points {[}p0, ... ,(x,y){]}.

\item {} 
\textbf{\texttt{all}} -- (True) if True adds last vector from last and first point.

\end{itemize}

\item[{Returns}] \leavevmode
array of vectors {[}V0, ... , (V{[}n{]} = x{[}n+1{]}-x{[}n{]},y{[}n+1{]}-y{[}n{]}){]}.

\end{description}\end{quote}

\end{fulllineitems}

\index{rescale() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.rescale}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{rescale}}{\emph{arr}, \emph{max=1}, \emph{min=0}}{}
Rescales array values to range {[}min,max{]}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{arr}} -- array.

\item {} 
\textbf{\texttt{max}} -- maximum value in range.

\item {} 
\textbf{\texttt{min}} -- minimum value in range.

\end{itemize}

\item[{Returns}] \leavevmode
rescaled array.

\end{description}\end{quote}

\end{fulllineitems}

\index{separePointsByAxis() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.separePointsByAxis}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{separePointsByAxis}}{\emph{pts}, \emph{ptaxis=(1}, \emph{0)}, \emph{origin=(0}, \emph{0)}}{}
Separate scattered points with respect to axis (splitting line).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{pts}} -- points to separate.

\item {} 
\textbf{\texttt{ptaxis}} -- point to form axis from origin

\item {} 
\textbf{\texttt{origin}} -- origin

\end{itemize}

\item[{Returns}] \leavevmode
left, right points from axis.

\end{description}\end{quote}

\end{fulllineitems}

\index{splitPoints() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.splitPoints}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{splitPoints}}{\emph{pts}, \emph{aslist=None}}{}
from points get x,y columns
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{pts}} -- array of points

\item {} 
\textbf{\texttt{aslist}} -- True to return lists instead of arrays

\end{itemize}

\item[{Returns}] \leavevmode
x, y columns

\end{description}\end{quote}

\end{fulllineitems}

\index{standarizePoints() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.standarizePoints}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{standarizePoints}}{\emph{pts}, \emph{aslist=False}}{}
converts points to a standard form
:param pts: list or array of points
:param aslist: True to return list instead of array
:return: standard points

\end{fulllineitems}

\index{superpose() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.superpose}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{superpose}}{\emph{back}, \emph{fore}, \emph{H}, \emph{foreMask=None}, \emph{grow=True}}{}
Superpose foreground image to background image.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{back}} -- background image

\item {} 
\textbf{\texttt{fore}} -- foreground image

\item {} 
\textbf{\texttt{H}} -- transformation matrix of fore to overlay in back

\item {} 
\textbf{\texttt{foreMask}} -- (None) foreground alpha mask, None or function.
foreMask values are from 1 for solid to 0 for transparency.
If a function is provided the new back,fore parameters are
provided to produce the foreMask. If None is provided
as foreMask then it is equivalent to a foreMask with all
values to 1 where fore is True.

\item {} 
\textbf{\texttt{grow}} -- If True, im can be bigger than back and is calculated
according to how fore is superposed in back; if False
im is of the same shape as back.

\end{itemize}

\item[{Returns}] \leavevmode
im, H\_back, H\_fore

\end{description}\end{quote}

\end{fulllineitems}

\index{transformPoint() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.transformPoint}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{transformPoint}}{\emph{p}, \emph{H}}{}
Transform individual x,y point with Transformation Matrix.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{p}} -- x,y point

\item {} 
\textbf{\texttt{H}} -- transformation matrix

\end{itemize}

\item[{Returns}] \leavevmode
transformed x,y point

\end{description}\end{quote}

\end{fulllineitems}

\index{transformPoints() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.transformPoints}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{transformPoints}}{\emph{p}, \emph{H}}{}
Transform x,y points in array with Transformation Matrix.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{p}} -- array of points

\item {} 
\textbf{\texttt{H}} -- transformation matrix

\end{itemize}

\item[{Returns}] \leavevmode
transformed array of x,y point

\end{description}\end{quote}

\end{fulllineitems}

\index{unit\_vector() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.unit_vector}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{unit\_vector}}{\emph{vector}}{}
Returns the unit vector of the vector.

\end{fulllineitems}

\index{vectorsAngles() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.vectorsAngles}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{vectorsAngles}}{\emph{pts}, \emph{ptaxis=(1}, \emph{0)}, \emph{origin=(0}, \emph{0)}, \emph{dtype=None}, \emph{deg=False}, \emph{absolute=None}}{}
Angle of formed vectors in Cartesian plane with respect to formed axis vector.
\begin{description}
\item[{i.e. angle between vector ``Vn'' (formed by point ``Pn'' and the ``origin'')}] \leavevmode\begin{quote}

and vector ``Vaxis'' formed by ``ptaxis'' and the ``origin''.
\end{quote}

where pts-origin = (P0-origin ... Pn-origin) = V0 ... Vn

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{pts}} -- points to form vectors from origin

\item {} 
\textbf{\texttt{ptaxis}} -- point to form axis from origin

\item {} 
\textbf{\texttt{origin}} -- origin

\item {} 
\textbf{\texttt{dtype}} -- return array of type supported by numpy.

\item {} 
\textbf{\texttt{deg}} -- if True angle is in Degrees, else radians.

\item {} 
\textbf{\texttt{absolute}} -- if None returns angles (0 yo 180(pi)) between  pts-origin (V0 .. Vn) and Vaxis.
if True returns any Vn absolute angle (0 to 360(2pi)) from Vaxis as axis to Vn.
if False returns any Vn angle (0 to 180 or 0 to -180) from Vaxis as axis to Vn,
where any Vn angle is positive or negative if counter-clock or clock wise from Vaxis.

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{vectorsQuadrants() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.vectorsQuadrants}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{vectorsQuadrants}}{\emph{vecs}}{}
Get quadrants of vectors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{vecs}} -- array of vectors.

\item[{Returns}] \leavevmode
quadrants.

\end{description}\end{quote}

\end{fulllineitems}

\index{vertexesAngles() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.vertexesAngles}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{vertexesAngles}}{\emph{pts}, \emph{dtype=None}, \emph{deg=False}}{}
Relative angle of vectors formed by vertexes (where vectors cross).
\begin{description}
\item[{i.e. angle between vectors ``v01'' formed by points ``p0-p1'' and ``v12''}] \leavevmode
formed by points ``p1-p2'' where ``p1'' is seen as a vertex (where vectors cross).

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{pts}} -- points seen as vertexes (vectors are recreated from point to point).

\item {} 
\textbf{\texttt{dtype}} -- return array of type supported by numpy.

\item {} 
\textbf{\texttt{deg}} -- if True angle is in Degrees, else radians.

\end{itemize}

\item[{Returns}] \leavevmode
angles.

\end{description}\end{quote}

\end{fulllineitems}

\index{view\_as\_blocks() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.view_as_blocks}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{view\_as\_blocks}}{\emph{arr\_in}, \emph{block\_shape=(3}, \emph{3)}}{}
Provide a 2D block\_shape view to 2D array. No error checking made.
Therefore meaningful (as implemented) only for blocks strictly
compatible with the shape of arr\_in.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{arr\_in}} -- 

\item {} 
\textbf{\texttt{block\_shape}} -- 

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{view\_as\_windows() (in module RRtoolbox.lib.arrayops.basic)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.basic.view_as_windows}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.basic.}\bfcode{view\_as\_windows}}{\emph{arr\_in}, \emph{window\_shape}, \emph{step=1}}{}
Provide a 2D block\_shape rolling view to 2D array. No error checking made.
Therefore meaningful (as implemented) only for blocks strictly
compatible with the shape of arr\_in.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{arr\_in}} -- 

\item {} 
\textbf{\texttt{window\_shape}} -- 

\item {} 
\textbf{\texttt{step}} -- 

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{RRtoolbox.lib.arrayops.convert module}
\label{RRtoolbox.lib.arrayops:module-RRtoolbox.lib.arrayops.convert}\label{RRtoolbox.lib.arrayops:rrtoolbox-lib-arrayops-convert-module}\index{RRtoolbox.lib.arrayops.convert (module)}
This module unlike common and basic array operations classifies just the from-to-conversions methods
\index{SimKeyPoint (class in RRtoolbox.lib.arrayops.convert)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.convert.SimKeyPoint}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.arrayops.convert.}\bfcode{SimKeyPoint}}{\emph{*args}}{}
Simulates opencv keypoint (it allows manipulation, conversion and serialization of keypoints).

\begin{notice}{note}{Note:}
Used for conversions and data persistence.
\end{notice}

\end{fulllineitems}

\index{apply2kp\_pairs() (in module RRtoolbox.lib.arrayops.convert)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.convert.apply2kp_pairs}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.convert.}\bfcode{apply2kp\_pairs}}{\emph{kp\_pairs}, \emph{kp1\_rel}, \emph{kp2\_rel}, \emph{func=None}}{}
Apply to kp\_pairs.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{kp\_pairs}} -- list of (kp1,kp2) pairs

\item {} 
\textbf{\texttt{kp1\_rel}} -- x,y relation or function to apply to kp1

\item {} 
\textbf{\texttt{kp2\_rel}} -- x,y relation or function to apply to kp2

\item {} 
\textbf{\texttt{func}} -- function to build new copy of keypoint

\end{itemize}

\item[{Returns}] \leavevmode
transformed kp\_pairs

\end{description}\end{quote}

\end{fulllineitems}

\index{cnt2pts() (in module RRtoolbox.lib.arrayops.convert)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.convert.cnt2pts}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.convert.}\bfcode{cnt2pts}}{\emph{contours}}{}
Convert contours to points. (cnt2pts)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{contours}} -- array of contours (cnt) ({[}{[}x,y{]}{]} only for openCV)

\item[{Returns}] \leavevmode


\end{description}\end{quote}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{contours} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} contours}
\PYG{n}{points} \PYG{o}{=} \PYG{n}{contour2points}\PYG{p}{(}\PYG{n}{contours}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{points} \PYG{c+c1}{\PYGZsh{} np.array([[0, 0], [1, 0]])}
\end{Verbatim}

\end{fulllineitems}

\index{contour2points() (in module RRtoolbox.lib.arrayops.convert)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.convert.contour2points}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.convert.}\bfcode{contour2points}}{\emph{contours}}{}
Convert contours to points. (cnt2pts)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{contours}} -- array of contours (cnt) ({[}{[}x,y{]}{]} only for openCV)

\item[{Returns}] \leavevmode


\end{description}\end{quote}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{contours} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} contours}
\PYG{n}{points} \PYG{o}{=} \PYG{n}{contour2points}\PYG{p}{(}\PYG{n}{contours}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{points} \PYG{c+c1}{\PYGZsh{} np.array([[0, 0], [1, 0]])}
\end{Verbatim}

\end{fulllineitems}

\index{conv3H4H() (in module RRtoolbox.lib.arrayops.convert)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.convert.conv3H4H}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.convert.}\bfcode{conv3H4H}}{\emph{M}}{}
Convert a 3D transformation matrix (TM) to 4D TM.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{M}} -- Matrix

\item[{Returns}] \leavevmode
4D Matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{dict2keyPoint() (in module RRtoolbox.lib.arrayops.convert)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.convert.dict2keyPoint}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.convert.}\bfcode{dict2keyPoint}}{\emph{d}, \emph{func=\textless{}built-in function KeyPoint\textgreater{}}}{}
KeyPoint({[}x, y, \_size{[}, \_angle{[}, \_response{[}, \_octave{[}, \_class\_id{]}{]}{]}{]}{]}) -\textgreater{} \textless{}KeyPoint object\textgreater{}

\end{fulllineitems}

\index{getSOpointRelation() (in module RRtoolbox.lib.arrayops.convert)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.convert.getSOpointRelation}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.convert.}\bfcode{getSOpointRelation}}{\emph{source\_shape}, \emph{destine\_shape}, \emph{asMatrix=False}}{}
Return parameters to change scaled point to original point.
\begin{quote}

\# destine\_domain = relation*source\_domain
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{source\_shape}} -- image shape for source domain

\item {} 
\textbf{\texttt{destine\_shape}} -- image shape for destine domain

\item {} 
\textbf{\texttt{asMatrix}} -- if true returns a Transformation Matrix H

\end{itemize}

\item[{Returns}] \leavevmode
x, y coordinate relations or H if asMatrix is True

\end{description}\end{quote}

\begin{notice}{note}{Note:}
Used to get relations to convert scaled points to original points of an Image.
\end{notice}

\end{fulllineitems}

\index{invertH() (in module RRtoolbox.lib.arrayops.convert)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.convert.invertH}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.convert.}\bfcode{invertH}}{\emph{H}}{}
Invert Transformation Matrix.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{H}} -- 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{keyPoint2tuple() (in module RRtoolbox.lib.arrayops.convert)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.convert.keyPoint2tuple}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.convert.}\bfcode{keyPoint2tuple}}{\emph{keypoint}}{}
obj.angle, obj.class\_id, obj.octave, obj.pt, obj.response, obj.size

\end{fulllineitems}

\index{points2contour() (in module RRtoolbox.lib.arrayops.convert)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.convert.points2contour}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.convert.}\bfcode{points2contour}}{\emph{points}}{}
Convert points to contours. (pts2cnt)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{points}} -- array of points ({[}x,y{]} for openCV, {[}y,x{]} for numpy)

\item[{Returns}] \leavevmode


\end{description}\end{quote}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{points} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} points}
\PYG{n}{contours} \PYG{o}{=} \PYG{n}{points2contour}\PYG{p}{(}\PYG{n}{points}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{contours} \PYG{c+c1}{\PYGZsh{} np.array([[[0, 0]], [[1, 0]]])}
\end{Verbatim}

\end{fulllineitems}

\index{points2vectos() (in module RRtoolbox.lib.arrayops.convert)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.convert.points2vectos}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.convert.}\bfcode{points2vectos}}{\emph{pts}, \emph{origin=None}}{}
Convert points to vectors with respect to origin.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{pts}} -- array of points.

\item {} 
\textbf{\texttt{origin}} -- point of origin.

\end{itemize}

\item[{Returns}] \leavevmode
vectors.

\end{description}\end{quote}

\end{fulllineitems}

\index{pts2cnt() (in module RRtoolbox.lib.arrayops.convert)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.convert.pts2cnt}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.convert.}\bfcode{pts2cnt}}{\emph{points}}{}
Convert points to contours. (pts2cnt)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{points}} -- array of points ({[}x,y{]} for openCV, {[}y,x{]} for numpy)

\item[{Returns}] \leavevmode


\end{description}\end{quote}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{points} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} points}
\PYG{n}{contours} \PYG{o}{=} \PYG{n}{points2contour}\PYG{p}{(}\PYG{n}{points}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{contours} \PYG{c+c1}{\PYGZsh{} np.array([[[0, 0]], [[1, 0]]])}
\end{Verbatim}

\end{fulllineitems}

\index{sh2oh() (in module RRtoolbox.lib.arrayops.convert)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.convert.sh2oh}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.convert.}\bfcode{sh2oh}}{\emph{sH}, \emph{osrc\_sh}, \emph{sscr\_sh}, \emph{odst\_sh}, \emph{sdst\_sh}}{}
Convert scaled transformation matrix (sH) to original (oH).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{sH}} -- scaled transformation matrix

\item {} 
\textbf{\texttt{osrc\_sh}} -- original source's shape

\item {} 
\textbf{\texttt{sscr\_sh}} -- scaled source's shape

\item {} 
\textbf{\texttt{odst\_sh}} -- original destine's shape

\item {} 
\textbf{\texttt{sdst\_sh}} -- scaled destine's shape

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{spairs2opairs() (in module RRtoolbox.lib.arrayops.convert)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.convert.spairs2opairs}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.convert.}\bfcode{spairs2opairs}}{\emph{kp\_pairs}, \emph{osrc\_sh}, \emph{sscr\_sh}, \emph{odst\_sh}, \emph{sdst\_sh}, \emph{func=None}}{}
Convert scaled kp\_pairs to original kp\_pairs.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{kp\_pairs}} -- list of kp\_pairs

\item {} 
\textbf{\texttt{osrc\_sh}} -- original source's shape

\item {} 
\textbf{\texttt{sscr\_sh}} -- scaled source's shape

\item {} 
\textbf{\texttt{odst\_sh}} -- original destine's shape

\item {} 
\textbf{\texttt{sdst\_sh}} -- scaled destine's shape

\item {} 
\textbf{\texttt{func}} -- function to build new copy of keypoint

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{spoint2opointfunc() (in module RRtoolbox.lib.arrayops.convert)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.convert.spoint2opointfunc}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.convert.}\bfcode{spoint2opointfunc}}{\emph{source\_shape}, \emph{destine\_shape}}{}
Return function with parameters to change scaled point to original point.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{source\_shape}} -- 

\item {} 
\textbf{\texttt{destine\_shape}} -- shape of

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{forefunc} \PYG{o}{=} \PYG{n}{scaled2realfunc}\PYG{p}{(}\PYG{n}{imgf}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{,}\PYG{n}{bgr}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
\PYG{n}{backfunc} \PYG{o}{=} \PYG{n}{scaled2realfunc}\PYG{p}{(}\PYG{n}{imgb}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{,}\PYG{n}{back}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
\PYG{n}{p1fore} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{forefunc}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{p1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{p2back} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{backfunc}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{p2}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\index{toTupple() (in module RRtoolbox.lib.arrayops.convert)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.convert.toTupple}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.convert.}\bfcode{toTupple}}{\emph{obj}}{}
Converts recursively to tuple
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{obj}} -- numpy array, list structure, iterators, etc.

\item[{Returns}] \leavevmode
tuple representation obj.

\end{description}\end{quote}

\end{fulllineitems}

\index{translateQuadrants() (in module RRtoolbox.lib.arrayops.convert)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.convert.translateQuadrants}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.convert.}\bfcode{translateQuadrants}}{\emph{quadrants}, \emph{quadrantmap=\{(0}, \emph{1): `up'}, \emph{(-1}, \emph{1): `left-up'}, \emph{(0}, \emph{0): `origin'}, \emph{(-1}, \emph{0): `left'}, \emph{(-1}, \emph{-1): `left-down'}, \emph{(0}, \emph{-1): `down'}, \emph{(1}, \emph{0): `right'}, \emph{(1}, \emph{-1): `right-down'}, \emph{(1}, \emph{1): `right-up'\}}}{}
Convert quadrants into human readable data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{quadrants}} -- array of quadrants.

\item {} 
\textbf{\texttt{quadrantmap}} -- 
dictionary map to translate quadrants. it is of the form:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZob{}(0,0):\PYGZdq{}origin\PYGZdq{},(1,0):\PYGZdq{}right\PYGZdq{},(1,1):\PYGZdq{}top\PYGZhy{}right\PYGZdq{},(0,1):\PYGZdq{}top\PYGZdq{},(\PYGZhy{}1,1):\PYGZdq{}top\PYGZhy{}left\PYGZdq{},
\end{Verbatim}
\begin{quote}

(-1,0):''left'',(-1,-1):''bottom-left'',(0,-1):''bottom'',(1,-1):''bottom-right''\}
\end{quote}


\end{itemize}

\item[{Returns}] \leavevmode
list of translated quadrants.

\end{description}\end{quote}

\end{fulllineitems}

\index{tuple2keyPoint() (in module RRtoolbox.lib.arrayops.convert)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.convert.tuple2keyPoint}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.convert.}\bfcode{tuple2keyPoint}}{\emph{points}, \emph{func=\textless{}built-in function KeyPoint\textgreater{}}}{}
KeyPoint({[}x, y, \_size{[}, \_angle{[}, \_response{[}, \_octave{[}, \_class\_id{]}{]}{]}{]}{]}) -\textgreater{} \textless{}KeyPoint object\textgreater{}

\end{fulllineitems}

\index{vectos2points() (in module RRtoolbox.lib.arrayops.convert)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.convert.vectos2points}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.convert.}\bfcode{vectos2points}}{\emph{vecs}, \emph{origin=None}}{}
Convert points to vectors with respect to origin.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{vecs}} -- array of vectors.

\item {} 
\textbf{\texttt{origin}} -- point of origin.

\end{itemize}

\item[{Returns}] \leavevmode
points.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{RRtoolbox.lib.arrayops.filters module}
\label{RRtoolbox.lib.arrayops:rrtoolbox-lib-arrayops-filters-module}\label{RRtoolbox.lib.arrayops:module-RRtoolbox.lib.arrayops.filters}\index{RRtoolbox.lib.arrayops.filters (module)}
This module contains custom 1D adn 2D-array filters and pre-processing (as in filtering phase) methods
\index{BilateralParameters (class in RRtoolbox.lib.arrayops.filters)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.BilateralParameters}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.arrayops.filters.}\bfcode{BilateralParameters}}{\emph{d=None}, \emph{sigmaColor=None}, \emph{sigmaSpace=None}}{}
Bases: \code{object}

create instance to calculate bilateral
parameters from image shape.
\begin{description}
\item[{d -\textgreater{} inf then:}] \leavevmode\begin{itemize}
\item {} 
computation is slower

\item {} 
filtering is better to eliminate noise

\item {} 
images look more cartoon-like

\end{itemize}

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{d}} -- distance

\item {} 
\textbf{\texttt{sigmaColor}} -- sigma in color

\item {} 
\textbf{\texttt{sigmaSpace}} -- sigma in space

\end{itemize}

\end{description}\end{quote}
\index{d (RRtoolbox.lib.arrayops.filters.BilateralParameters attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.BilateralParameters.d}\pysigline{\bfcode{d}\strong{ = 27}}
\end{fulllineitems}

\index{d\_h (RRtoolbox.lib.arrayops.filters.BilateralParameters attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.BilateralParameters.d_h}\pysigline{\bfcode{d\_h}\strong{ = \textless{}RRtoolbox.lib.arrayops.filters.bilateraP object\textgreater{}}}
\end{fulllineitems}

\index{filters (RRtoolbox.lib.arrayops.filters.BilateralParameters attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.BilateralParameters.filters}\pysigline{\bfcode{filters}}
list of filters

\end{fulllineitems}

\index{sigmaColor (RRtoolbox.lib.arrayops.filters.BilateralParameters attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.BilateralParameters.sigmaColor}\pysigline{\bfcode{sigmaColor}\strong{ = \textless{}RRtoolbox.lib.arrayops.filters.bilateraP object\textgreater{}}}
\end{fulllineitems}

\index{sigmaSpace (RRtoolbox.lib.arrayops.filters.BilateralParameters attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.BilateralParameters.sigmaSpace}\pysigline{\bfcode{sigmaSpace}\strong{ = \textless{}RRtoolbox.lib.arrayops.filters.bilateraP object\textgreater{}}}
\end{fulllineitems}


\end{fulllineitems}

\index{FilterBase (class in RRtoolbox.lib.arrayops.filters)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.FilterBase}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.arrayops.filters.}\bfcode{FilterBase}}{\emph{alpha=None}, \emph{beta1=None}, \emph{beta2=None}}{}
Bases: \code{object}

base filter to create custom filters
\index{alpha (RRtoolbox.lib.arrayops.filters.FilterBase attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.FilterBase.alpha}\pysigline{\bfcode{alpha}}
\end{fulllineitems}

\index{beta1 (RRtoolbox.lib.arrayops.filters.FilterBase attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.FilterBase.beta1}\pysigline{\bfcode{beta1}}
\end{fulllineitems}

\index{beta2 (RRtoolbox.lib.arrayops.filters.FilterBase attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.FilterBase.beta2}\pysigline{\bfcode{beta2}}
\end{fulllineitems}


\end{fulllineitems}

\index{bandpass (class in RRtoolbox.lib.arrayops.filters)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.bandpass}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.arrayops.filters.}\bfcode{bandpass}}{\emph{alpha}, \emph{beta1}, \emph{beta2}}{}
Bases: {\hyperref[RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.FilterBase]{\emph{\code{RRtoolbox.lib.arrayops.filters.FilterBase}}}}

bandpass filter

\end{fulllineitems}

\index{bandstop (class in RRtoolbox.lib.arrayops.filters)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.bandstop}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.arrayops.filters.}\bfcode{bandstop}}{\emph{alpha}, \emph{beta1}, \emph{beta2}}{}
Bases: {\hyperref[RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.FilterBase]{\emph{\code{RRtoolbox.lib.arrayops.filters.FilterBase}}}}

bandstop filter

\end{fulllineitems}

\index{bilateraP (class in RRtoolbox.lib.arrayops.filters)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.bilateraP}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.arrayops.filters.}\bfcode{bilateraP}}{\emph{scale}, \emph{shift=33}, \emph{name=None}, \emph{alpha=100}, \emph{beta1=-400}, \emph{beta2=200}}{}
Bases: {\hyperref[RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.bandstop]{\emph{\code{RRtoolbox.lib.arrayops.filters.bandstop}}}}

bilateral parameter

\end{fulllineitems}

\index{bilateralFilter() (in module RRtoolbox.lib.arrayops.filters)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.bilateralFilter}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.filters.}\bfcode{bilateralFilter}}{\emph{*args}, \emph{**kwargs}}{}
Apply bilateral Filter.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{im}} -- 

\item {} 
\textbf{\texttt{d}} -- 

\item {} 
\textbf{\texttt{sigmaColor}} -- 

\item {} 
\textbf{\texttt{sigmaSpace}} -- 

\end{itemize}

\item[{Returns}] \leavevmode
filtered image

\end{description}\end{quote}

\end{fulllineitems}

\index{filterFactory() (in module RRtoolbox.lib.arrayops.filters)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.filterFactory}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.filters.}\bfcode{filterFactory}}{\emph{alpha}, \emph{beta1}, \emph{beta2=None}}{}
Make filter.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{alpha}} -- steepness of filter

\item {} 
\textbf{\texttt{beta1}} -- first shift from origin

\item {} 
\textbf{\texttt{beta2}} -- 
second shift from origin:

alpha must be != 0
if beta2 = None:
\begin{quote}

if alpha \textgreater{} 0: high-pass filter, if alpha \textless{} 0: low-pass filter
\end{quote}
\begin{description}
\item[{else:}] \leavevmode\begin{description}
\item[{if beta2 \textgreater{} beta1:}] \leavevmode
if alpha \textgreater{} 0: band-pass filter, if alpha \textless{} 0: band-stop filter

\item[{else:}] \leavevmode
if alpha \textgreater{} 0: inverted-band-pass filter, if alpha \textless{} 0: inverted-band-stop filter

\end{description}

\end{description}


\end{itemize}

\item[{Returns}] \leavevmode
filter funtion with intup levels

\end{description}\end{quote}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{alpha}\PYG{p}{,}\PYG{n}{beta1}\PYG{p}{,}\PYG{n}{beta2} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{100}
\PYG{n}{myfilter} \PYG{o}{=} \PYG{n+nb}{filter}\PYG{p}{(}\PYG{n}{alpha}\PYG{p}{,}\PYG{n}{beta1}\PYG{p}{,}\PYG{n}{beta2}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{myfilter}\PYG{p}{,}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{myfilter}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{myfilter}\PYG{o}{.}\PYG{n}{alpha}\PYG{p}{,}\PYG{n}{myfilter}\PYG{o}{.}\PYG{n}{beta1}\PYG{p}{,}\PYG{n}{myfilter}\PYG{o}{.}\PYG{n}{beta2}
\end{Verbatim}

\end{fulllineitems}

\index{highpass (class in RRtoolbox.lib.arrayops.filters)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.highpass}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.arrayops.filters.}\bfcode{highpass}}{\emph{alpha}, \emph{beta1}}{}
Bases: {\hyperref[RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.FilterBase]{\emph{\code{RRtoolbox.lib.arrayops.filters.FilterBase}}}}

highpass filter

\end{fulllineitems}

\index{invertedbandpass (class in RRtoolbox.lib.arrayops.filters)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.invertedbandpass}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.arrayops.filters.}\bfcode{invertedbandpass}}{\emph{alpha}, \emph{beta1}, \emph{beta2}}{}
Bases: {\hyperref[RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.bandpass]{\emph{\code{RRtoolbox.lib.arrayops.filters.bandpass}}}}

inverted bandpass filter

\end{fulllineitems}

\index{invertedbandstop (class in RRtoolbox.lib.arrayops.filters)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.invertedbandstop}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.arrayops.filters.}\bfcode{invertedbandstop}}{\emph{alpha}, \emph{beta1}, \emph{beta2}}{}
Bases: {\hyperref[RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.bandstop]{\emph{\code{RRtoolbox.lib.arrayops.filters.bandstop}}}}

inverted bandstop filter

\end{fulllineitems}

\index{lowpass (class in RRtoolbox.lib.arrayops.filters)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.lowpass}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.arrayops.filters.}\bfcode{lowpass}}{\emph{alpha}, \emph{beta1}}{}
Bases: {\hyperref[RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.FilterBase]{\emph{\code{RRtoolbox.lib.arrayops.filters.FilterBase}}}}

lowpass filter

\end{fulllineitems}

\index{normsigmoid() (in module RRtoolbox.lib.arrayops.filters)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.normsigmoid}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.filters.}\bfcode{normsigmoid}}{\emph{x}, \emph{alpha}, \emph{beta}}{}
Apply normalized sigmoid filter.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{x}} -- data to apply filter

\item {} 
\textbf{\texttt{alpha}} -- if alpha \textgreater{} 0: pass high filter, if alpha \textless{} 0: pass low filter, alpha must be != 0

\item {} 
\textbf{\texttt{beta}} -- shift from origin

\end{itemize}

\item[{Returns}] \leavevmode
filtered values normalized to range {[}-1 if x\textless{}0, 1 if x\textgreater{}=0{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{sigmoid() (in module RRtoolbox.lib.arrayops.filters)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.sigmoid}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.filters.}\bfcode{sigmoid}}{\emph{x}, \emph{alpha}, \emph{beta}, \emph{max=255}, \emph{min=0}}{}
Apply sigmoid filter.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{x}} -- data to apply filter

\item {} 
\textbf{\texttt{alpha}} -- if alpha \textgreater{} 0: pass high filter, if alpha \textless{} 0: pass low filter, alpha must be != 0

\item {} 
\textbf{\texttt{beta}} -- shift from origin

\item {} 
\textbf{\texttt{max}} -- maximum output value

\item {} 
\textbf{\texttt{min}} -- minimum output value

\end{itemize}

\item[{Returns}] \leavevmode
filtered values ranging as {[}min,max{]}

\end{description}\end{quote}

\begin{notice}{note}{Note:}
Based from \href{http://www.itk.org/Doxygen/html/classitk\_1\_1SigmoidImageFilter.html}{http://www.itk.org/Doxygen/html/classitk\_1\_1SigmoidImageFilter.html}
\end{notice}

\end{fulllineitems}

\index{smooth() (in module RRtoolbox.lib.arrayops.filters)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.filters.smooth}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.filters.}\bfcode{smooth}}{\emph{x}, \emph{window\_len=11}, \emph{window='hanning'}, \emph{correct=False}}{}
Smooth the data using a window with requested size.

This method is based on the convolution of a scaled window with the signal.
The signal is prepared by introducing reflected copies of the signal
(with the window size) in both ends so that transient parts are minimized
in the begining and end part of the output signal.
\begin{description}
\item[{input:}] \leavevmode
x: the input signal
window\_len: the dimension of the smoothing window; should be an odd integer
window: the type of window from `flat', `hanning', `hamming', `bartlett', `blackman'
\begin{quote}

flat window will produce a moving average smoothing.
\end{quote}

\item[{output:}] \leavevmode
the smoothed signal

\end{description}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{t}\PYG{o}{=}\PYG{n}{linspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mf}{0.1}\PYG{p}{)}
\PYG{n}{x}\PYG{o}{=}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{o}{+}\PYG{n}{randn}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{0.1}
\PYG{n}{y}\PYG{o}{=}\PYG{n}{smooth}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\end{Verbatim}


\strong{See also:}


numpy.hanning, numpy.hamming, numpy.bartlett, numpy.blackman, numpy.convolve, scipy.signal.lfilter



\begin{notice}{note}{Note:}
length(output) != length(input), to correct this: return y{[}(window\_len/2-1):-(window\_len/2){]} instead of just y.
\end{notice}

\end{fulllineitems}



\subparagraph{RRtoolbox.lib.arrayops.mask module}
\label{RRtoolbox.lib.arrayops:module-RRtoolbox.lib.arrayops.mask}\label{RRtoolbox.lib.arrayops:rrtoolbox-lib-arrayops-mask-module}\index{RRtoolbox.lib.arrayops.mask (module)}
This module contains all basic masking and pre-processing (as in segmenting phase) methods
\index{background() (in module RRtoolbox.lib.arrayops.mask)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.mask.background}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.mask.}\bfcode{background}}{\emph{gray}, \emph{mask=None}, \emph{iterations=3}}{}
get the background mask of a gray image. (this it the inverted of {\hyperref[RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.mask.foreground]{\emph{\code{foreground()}}}})
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{gray}} -- gray image

\item {} 
\textbf{\texttt{mask}} -- (None) input mask to process gray

\item {} 
\textbf{\texttt{iterations}} -- (3) number of iterations to detect background
with otsu threshold.

\end{itemize}

\item[{Returns}] \leavevmode
output mask

\end{description}\end{quote}

\end{fulllineitems}

\index{biggestCnt() (in module RRtoolbox.lib.arrayops.mask)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.mask.biggestCnt}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.mask.}\bfcode{biggestCnt}}{\emph{contours}}{}
Filters contours to get biggest contour.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{contours}} -- 

\item[{Returns}] \leavevmode
cnt

\end{description}\end{quote}

\end{fulllineitems}

\index{biggestCntData() (in module RRtoolbox.lib.arrayops.mask)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.mask.biggestCntData}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.mask.}\bfcode{biggestCntData}}{\emph{contours}}{}
Gets index and area of biggest contour.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{contours}} -- 

\item[{Returns}] \leavevmode
index, area

\end{description}\end{quote}

\end{fulllineitems}

\index{brightness() (in module RRtoolbox.lib.arrayops.mask)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.mask.brightness}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.mask.}\bfcode{brightness}}{\emph{img}}{}
get brightness from an image
:param img: BGR or gray image
:return:

\end{fulllineitems}

\index{cnt\_hist() (in module RRtoolbox.lib.arrayops.mask)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.mask.cnt_hist}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.mask.}\bfcode{cnt\_hist}}{\emph{gray}}{}
Mask of a ellipse enclosing retina using histogram threshold.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{gray}} -- gray image

\item {} 
\textbf{\texttt{invert}} -- invert mask

\end{itemize}

\item[{Returns}] \leavevmode
mask

\end{description}\end{quote}

\end{fulllineitems}

\index{foreground() (in module RRtoolbox.lib.arrayops.mask)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.mask.foreground}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.mask.}\bfcode{foreground}}{\emph{gray}, \emph{mask=None}, \emph{iterations=3}}{}
get the foreground mask of a gray image. (this it the inverted of {\hyperref[RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.mask.background]{\emph{\code{background()}}}})
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{gray}} -- gray image

\item {} 
\textbf{\texttt{mask}} -- (None) input mask to process gray

\item {} 
\textbf{\texttt{iterations}} -- (3) number of iterations to detect foreground
with otsu threshold.

\end{itemize}

\item[{Returns}] \leavevmode
output mask

\end{description}\end{quote}

\end{fulllineitems}

\index{gethull() (in module RRtoolbox.lib.arrayops.mask)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.mask.gethull}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.mask.}\bfcode{gethull}}{\emph{contours}}{}
Get convex hull.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{contours}} -- contours or mask array

\item[{Returns}] \leavevmode
cnt

\end{description}\end{quote}

\end{fulllineitems}

\index{hist\_cdf() (in module RRtoolbox.lib.arrayops.mask)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.mask.hist_cdf}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.mask.}\bfcode{hist\_cdf}}{\emph{img}, \emph{window\_len=0}, \emph{window='hanning'}}{}
Get image histogram and the normalized cumulative distribution function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{img}} -- imaeg

\item {} 
\textbf{\texttt{window\_len}} -- 

\item {} 
\textbf{\texttt{window}} -- 

\end{itemize}

\item[{Returns}] \leavevmode
histogram (int), normalized cdf (float)

\end{description}\end{quote}

\end{fulllineitems}

\index{mask\_watershed() (in module RRtoolbox.lib.arrayops.mask)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.mask.mask_watershed}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.mask.}\bfcode{mask\_watershed}}{\emph{BGR}, \emph{GRAY=None}}{}
Get retinal mask with watershed method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{BGR}} -- 

\item {} 
\textbf{\texttt{GRAY}} -- 

\end{itemize}

\item[{Returns}] \leavevmode
mask

\end{description}\end{quote}

\end{fulllineitems}

\index{multiple\_otsu() (in module RRtoolbox.lib.arrayops.mask)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.mask.multiple_otsu}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.mask.}\bfcode{multiple\_otsu}}{\emph{gray}, \emph{mask=None}, \emph{flag=0L}, \emph{iterations=1}}{}
get the mask of a gray image applying Otsu threshold.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{gray}} -- gray image

\item {} 
\textbf{\texttt{mask}} -- (None) input mask to process gray

\item {} 
\textbf{\texttt{iterations}} -- \begin{enumerate}
\item {} 
number of iterations to detect Otsu threshold.

\end{enumerate}


\end{itemize}

\item[{Returns}] \leavevmode
thresh, mask

\end{description}\end{quote}

\end{fulllineitems}

\index{thresh\_biggestCnt() (in module RRtoolbox.lib.arrayops.mask)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.mask.thresh_biggestCnt}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.mask.}\bfcode{thresh\_biggestCnt}}{\emph{thresh}}{}
From threshold obtain biggest contour.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{thresh}} -- binary image

\item[{Returns}] \leavevmode
cnt

\end{description}\end{quote}

\end{fulllineitems}

\index{thresh\_hist() (in module RRtoolbox.lib.arrayops.mask)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.mask.thresh_hist}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.mask.}\bfcode{thresh\_hist}}{\emph{gray}}{}
Get best possible thresh to threshold object from the gray image.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{gray}} -- gray image.

\item[{Returns}] \leavevmode
thresh value.

\end{description}\end{quote}

\end{fulllineitems}

\index{threshold\_opening() (in module RRtoolbox.lib.arrayops.mask)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib.arrayops:RRtoolbox.lib.arrayops.mask.threshold_opening}\pysiglinewithargsret{\code{RRtoolbox.lib.arrayops.mask.}\bfcode{threshold\_opening}}{\emph{src}, \emph{thresh}, \emph{maxval}, \emph{type}}{}
Eliminate small objects from threshold.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{src}} -- 

\item {} 
\textbf{\texttt{thresh}} -- 

\item {} 
\textbf{\texttt{maxval}} -- 

\item {} 
\textbf{\texttt{type}} -- 

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{Module contents}
\label{RRtoolbox.lib.arrayops:module-RRtoolbox.lib.arrayops}\label{RRtoolbox.lib.arrayops:module-contents}\index{RRtoolbox.lib.arrayops (module)}

\subsubsection{Submodules}
\label{RRtoolbox.lib:submodules}

\subsubsection{RRtoolbox.lib.cache module}
\label{RRtoolbox.lib:rrtoolbox-lib-cache-module}\label{RRtoolbox.lib:module-RRtoolbox.lib.cache}\index{RRtoolbox.lib.cache (module)}\begin{quote}\begin{description}
\item[{platform}] \leavevmode
Unix, Windows

\item[{synopsis}] \leavevmode
Serialize and Memoize.

\end{description}\end{quote}

Contains memoizing, caching, serializing and memory-mapping methods so as to let the package
save its state (persistence) and to let a method ``remember'' what it processed in a session (with cache) or
between sessions (memoization and serializization) of the same input contend once processed. It also wraps mmapping
functions to let objects ``live'' in the disk (slower but almost unlimited) rather than in memory (faster but limited).

\emph{@cache} is used as replacement of \emph{@property} to compute a class method once.
It is computed only one time after which an attribute of the same name is generated in its place.

\emph{@cachedProperty} is used as replacement of \emph{@property} to compute
a class method depending on changes in its watched variables.

\emph{@memoize} used as a general memoizer decorator for functions
where metadata is generated to disk for persistence.

Made by Davtoh, powered by joblib.
Dependent project: \href{https://github.com/joblib/joblib}{https://github.com/joblib/joblib}
\index{DynamicMemoizedFunc (class in RRtoolbox.lib.cache)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.DynamicMemoizedFunc}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.cache.}\bfcode{DynamicMemoizedFunc}}{\emph{func}, \emph{cachedir=None}, \emph{ignore=None}, \emph{mmap\_mode=None}, \emph{compress=False}, \emph{verbose=1}, \emph{timestamp=None}, \emph{banned=False}}{}
Bases: \code{object}
\index{cachedir (RRtoolbox.lib.cache.DynamicMemoizedFunc attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.DynamicMemoizedFunc.cachedir}\pysigline{\bfcode{cachedir}}
\end{fulllineitems}

\index{call\_and\_shelve() (RRtoolbox.lib.cache.DynamicMemoizedFunc method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.DynamicMemoizedFunc.call_and_shelve}\pysiglinewithargsret{\bfcode{call\_and\_shelve}}{\emph{*args}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{clear() (RRtoolbox.lib.cache.DynamicMemoizedFunc method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.DynamicMemoizedFunc.clear}\pysiglinewithargsret{\bfcode{clear}}{\emph{warn=True}}{}
\end{fulllineitems}

\index{compress (RRtoolbox.lib.cache.DynamicMemoizedFunc attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.DynamicMemoizedFunc.compress}\pysigline{\bfcode{compress}}
\end{fulllineitems}

\index{enabled (RRtoolbox.lib.cache.DynamicMemoizedFunc attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.DynamicMemoizedFunc.enabled}\pysigline{\bfcode{enabled}}
\end{fulllineitems}

\index{func (RRtoolbox.lib.cache.DynamicMemoizedFunc attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.DynamicMemoizedFunc.func}\pysigline{\bfcode{func}}
\end{fulllineitems}

\index{ignore (RRtoolbox.lib.cache.DynamicMemoizedFunc attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.DynamicMemoizedFunc.ignore}\pysigline{\bfcode{ignore}}
\end{fulllineitems}

\index{mmap\_mode (RRtoolbox.lib.cache.DynamicMemoizedFunc attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.DynamicMemoizedFunc.mmap_mode}\pysigline{\bfcode{mmap\_mode}}
\end{fulllineitems}

\index{verbose (RRtoolbox.lib.cache.DynamicMemoizedFunc attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.DynamicMemoizedFunc.verbose}\pysigline{\bfcode{verbose}}
\end{fulllineitems}


\end{fulllineitems}

\index{Memoizer (class in RRtoolbox.lib.cache)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.Memoizer}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.cache.}\bfcode{Memoizer}}{\emph{ignore=()}, \emph{ignoreAll=False}}{}
Bases: \code{object}
\index{ignore (RRtoolbox.lib.cache.Memoizer attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.Memoizer.ignore}\pysigline{\bfcode{ignore}}
\end{fulllineitems}

\index{makememory() (RRtoolbox.lib.cache.Memoizer method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.Memoizer.makememory}\pysiglinewithargsret{\bfcode{makememory}}{\emph{cachedir=None}, \emph{mmap\_mode=None}, \emph{compress=False}, \emph{verbose=0}}{}
Make memory for {\hyperref[RRtoolbox.lib:RRtoolbox.lib.cache.Memoizer.memoize]{\emph{\code{memoize()}}}} decorator.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{cachedir}} -- path to save metadata, if left None function is not cached.

\item {} 
\textbf{\texttt{mmap\_mode}} -- \{None, `r+', `r', `w+', `c'\}, optional.
The memmapping mode used when loading from cache
numpy arrays. See numpy.load for the meaning of the
arguments.

\item {} 
\textbf{\texttt{compress}} -- (boolean or integer)
Whether to zip the stored data on disk. If an integer is
given, it should be between 1 and 9, and sets the amount
of compression. Note that compressed arrays cannot be
read by memmapping.

\item {} 
\textbf{\texttt{verbose}} -- (int, optional)
Verbosity flag, controls the debug messages that are issued
as functions are evaluated.

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{memoize() (RRtoolbox.lib.cache.Memoizer method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.Memoizer.memoize}\pysiglinewithargsret{\bfcode{memoize}}{\emph{memory=None}, \emph{ignore=None}, \emph{verbose=0}, \emph{mmap\_mode=False}}{}
Decorated functions are faster by trading memory for time, only hashable values can be memoized.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{memory}} -- (Memory or path to folder) if left None function is not cached.

\item {} 
\textbf{\texttt{ignore}} -- (list of strings) A list of arguments name to ignore in the hashing.

\item {} 
\textbf{\texttt{verbose}} -- (integer) Verbosity flag, controls the debug messages that are issued as functions are evaluated.

\item {} 
\textbf{\texttt{mmap\_mode}} -- \{None, `r+', `r', `w+', `c'\}, optional. The memmapping mode used when loading from cache
numpy arrays. See numpy.load for the meaning of the arguments.

\end{itemize}

\item[{Returns}] \leavevmode
decorator

\end{description}\end{quote}

\end{fulllineitems}

\index{memoizers (RRtoolbox.lib.cache.Memoizer attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.Memoizer.memoizers}\pysigline{\bfcode{memoizers}\strong{ = \{140716454851024: \textless{}weakref at 0x7ffb1a4e9208; to `Memoizer' at 0x7ffb1a4e31d0\textgreater{}\}}}
\end{fulllineitems}


\end{fulllineitems}

\index{MemorizedFunc (class in RRtoolbox.lib.cache)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.MemorizedFunc}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.cache.}\bfcode{MemorizedFunc}}{\emph{func}, \emph{cachedir}, \emph{ignore=None}, \emph{mmap\_mode=None}, \emph{compress=False}, \emph{verbose=1}, \emph{timestamp=None}}{}
Bases: \code{joblib.memory.MemorizedFunc}

\end{fulllineitems}

\index{Memory (class in RRtoolbox.lib.cache)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.Memory}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.cache.}\bfcode{Memory}}{\emph{cachedir}, \emph{mmap\_mode=None}, \emph{compress=False}, \emph{verbose=1}}{}
Bases: \code{joblib.memory.Memory}

A wrapper to joblib Memory to have better control.

\end{fulllineitems}

\index{NotMemorizedFunc (class in RRtoolbox.lib.cache)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.NotMemorizedFunc}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.cache.}\bfcode{NotMemorizedFunc}}{\emph{func}}{}
Bases: \code{joblib.memory.NotMemorizedFunc}

\end{fulllineitems}

\index{cache (class in RRtoolbox.lib.cache)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.cache}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.cache.}\bfcode{cache}}{\emph{func}}{}
Bases: \code{object}

Descriptor (non-data) for building an attribute on-demand at first use.
@cache decorator is used for class methods without inputs (only self reference to the object)
and it caches on first compute. ex:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{x}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nd}{@cache}
    \PYG{k}{def} \PYG{n+nf}{method\PYGZus{}x}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}
\end{Verbatim}

\begin{notice}{note}{Note:}
Cached data can be deleted in the decorated object to recalculate its value.
\end{notice}

\end{fulllineitems}

\index{cachedProperty() (in module RRtoolbox.lib.cache)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.cachedProperty}\pysiglinewithargsret{\code{RRtoolbox.lib.cache.}\bfcode{cachedProperty}}{\emph{watch={[}{]}}, \emph{handle={[}{]}}}{}
A memoize decorator of @property decorator specifying what to trigger caching.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{watch}} -- (list of strings) A list of arguments name to watch in the hashing.

\item {} 
\textbf{\texttt{handle}} -- (list of handles or empty list) Provided list is appended with the memo
handle were data is stored for the method and where a clear() function is provided.

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{mapper() (in module RRtoolbox.lib.cache)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.mapper}\pysiglinewithargsret{\code{RRtoolbox.lib.cache.}\bfcode{mapper}}{\emph{path}, \emph{obj=None}, \emph{mode=None}, \emph{onlynumpy=False}}{}
Save and load or map live objects to disk to free RAM memory.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{path}} -- path to save mapped file.

\item {} 
\textbf{\texttt{obj}} -- the object to map, if None it tries to load obj from path if exist

\item {} 
\textbf{\texttt{mode}} -- \{None, `r+', `r', `w+', `c'\}.

\item {} 
\textbf{\texttt{onlynumpy}} -- if True, it saves a numpy mapper from obj.

\end{itemize}

\item[{Returns}] \leavevmode
mmap image, names of mmap files

\end{description}\end{quote}

\end{fulllineitems}

\index{memoizedDict (class in RRtoolbox.lib.cache)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.memoizedDict}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.cache.}\bfcode{memoizedDict}}{\emph{path}, \emph{mode=None}}{}
Bases: \code{\_abcoll.MutableMapping}

memoized dictionary with keys and values persisted to files.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{path}} -- path to save memo file

\item {} 
\textbf{\texttt{mode}} -- loading mode from memo file \{None, `r+', `r', `w+', `c'\}

\end{itemize}

\end{description}\end{quote}

\begin{notice}{warning}{Warning:}
Some data structures cannot be memoize, so this structure is not save yet.
Use at your own risk.
\end{notice}
\index{clear() (RRtoolbox.lib.cache.memoizedDict method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.memoizedDict.clear}\pysiglinewithargsret{\bfcode{clear}}{}{}
Remove all items from D.

\end{fulllineitems}


\end{fulllineitems}

\index{notCallable}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.notCallable}\pysigline{\strong{exception }\code{RRtoolbox.lib.cache.}\bfcode{notCallable}}
Bases: \code{exceptions.Exception}

Defines objectGetter error: given object is not callable.

\end{fulllineitems}

\index{notCreatable}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.notCreatable}\pysigline{\strong{exception }\code{RRtoolbox.lib.cache.}\bfcode{notCreatable}}
Bases: \code{exceptions.Exception}

Defines objectGetter error: objectGetter cannot create new object.

\end{fulllineitems}

\index{objectGetter (class in RRtoolbox.lib.cache)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.objectGetter}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.cache.}\bfcode{objectGetter}}{\emph{callfunc=None}, \emph{obj=None}, \emph{callback=None}, \emph{**annotations}}{}
Bases: \code{object}

Creates or get instance object depending if it is alive.
\index{create() (RRtoolbox.lib.cache.objectGetter method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.objectGetter.create}\pysiglinewithargsret{\bfcode{create}}{\emph{throw=False}}{}
Creates an object and keep reference.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{throw}} -- if there is not creation function throws error.

\item[{Returns}] \leavevmode
created object.

\end{description}\end{quote}

\begin{notice}{warning}{Warning:}
previous object reference is lost even if it was alive.
\end{notice}

\begin{notice}{note}{Note:}
Recommended only to use when object from current reference is dead.
\end{notice}

\end{fulllineitems}

\index{getObj() (RRtoolbox.lib.cache.objectGetter method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.objectGetter.getObj}\pysiglinewithargsret{\bfcode{getObj}}{\emph{throw=False}}{}
\end{fulllineitems}

\index{isAlive() (RRtoolbox.lib.cache.objectGetter method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.objectGetter.isAlive}\pysiglinewithargsret{\bfcode{isAlive}}{}{}
test if object of reference is alive

\end{fulllineitems}

\index{isCreatable() (RRtoolbox.lib.cache.objectGetter method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.objectGetter.isCreatable}\pysiglinewithargsret{\bfcode{isCreatable}}{}{}
test if can create object

\end{fulllineitems}

\index{isGettable() (RRtoolbox.lib.cache.objectGetter method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.objectGetter.isGettable}\pysiglinewithargsret{\bfcode{isGettable}}{}{}
test if object can be gotten either by reference or creation.

\end{fulllineitems}

\index{raw() (RRtoolbox.lib.cache.objectGetter method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.objectGetter.raw}\pysiglinewithargsret{\bfcode{raw}}{}{}
get object from reference.
:return: None if object is dead, object itself if is alive.

\end{fulllineitems}

\index{update() (RRtoolbox.lib.cache.objectGetter method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.objectGetter.update}\pysiglinewithargsret{\bfcode{update}}{\emph{**kwargs}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{resourceManager (class in RRtoolbox.lib.cache)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.resourceManager}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.cache.}\bfcode{resourceManager}}{\emph{maxMemory=None}, \emph{margin=0.8}, \emph{unit='MB'}, \emph{all=True}}{}
Bases: {\hyperref[RRtoolbox.lib:RRtoolbox.lib.cache.retriever]{\emph{\code{RRtoolbox.lib.cache.retriever}}}}

keep track of references, create objects on demand, manage their memory and optimize for better performance.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{maxMemory}} -- (None) max memory in specified unit to keep in check optimization (it does
not mean that memory never surpasses maxMemory).

\item {} 
\textbf{\texttt{margin}} -- (0.8) margin from maxMemory to trigger optimization.
It is in percentage of maxMemory ranging from 0 (0\%) to maximum 1 (100\%).
So optimal memory is inside range: maxMemory*margin \textless{} Memory \textless{} maxMemory

\item {} 
\textbf{\texttt{unit}} -- (MB) maxMemory unit, it can be GB (Gigabytes), MB (Megabytes), B (bytes)

\item {} 
\textbf{\texttt{all}} -- if True used memory is from all alive references,
if False used memory is only from keptAlive references.

\end{itemize}

\end{description}\end{quote}
\index{all (RRtoolbox.lib.cache.resourceManager attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.resourceManager.all}\pysigline{\bfcode{all}}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
all flag, if True: used memory is from all alive references,
if False: used memory is only from keptAlive references.

\end{description}\end{quote}

\end{fulllineitems}

\index{bytes2units() (RRtoolbox.lib.cache.resourceManager method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.resourceManager.bytes2units}\pysiglinewithargsret{\bfcode{bytes2units}}{\emph{value}}{}
converts value from bytes to user units

\end{fulllineitems}

\index{getSizeOf() (RRtoolbox.lib.cache.resourceManager method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.resourceManager.getSizeOf}\pysiglinewithargsret{\bfcode{getSizeOf}}{\emph{item}}{}
\end{fulllineitems}

\index{keepAlive() (RRtoolbox.lib.cache.resourceManager method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.resourceManager.keepAlive}\pysiglinewithargsret{\bfcode{keepAlive}}{\emph{key}, \emph{obj}}{}
\end{fulllineitems}

\index{margin (RRtoolbox.lib.cache.resourceManager attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.resourceManager.margin}\pysigline{\bfcode{margin}}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
margin used for triggering memory optimization from maxMemory.

\end{description}\end{quote}

\end{fulllineitems}

\index{maxMemory (RRtoolbox.lib.cache.resourceManager attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.resourceManager.maxMemory}\pysigline{\bfcode{maxMemory}}
\end{fulllineitems}

\index{optimizeObject() (RRtoolbox.lib.cache.resourceManager method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.resourceManager.optimizeObject}\pysiglinewithargsret{\bfcode{optimizeObject}}{\emph{key}, \emph{getter}, \emph{toWhiteList=False}}{}
\end{fulllineitems}

\index{register() (RRtoolbox.lib.cache.resourceManager method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.resourceManager.register}\pysiglinewithargsret{\bfcode{register}}{\emph{key}, \emph{method=None}, \emph{instance=None}}{}
Register object to retrieve.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{key}} -- hashable key to retrieve

\item {} 
\textbf{\texttt{method}} -- callable method to get object

\item {} 
\textbf{\texttt{instance}} -- object instance already created from method

\end{itemize}

\end{description}\end{quote}

\begin{notice}{note}{Note:}
This method is used in \_\_setitem\_\_ as self.register(key, value). Overwrite this
method to change key assignation behaviour.
\end{notice}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{mymethod}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{class} \PYG{n+nc}{constructor}\PYG{p}{:} \PYG{k}{pass}
    \PYG{k}{return} \PYG{n}{constructor}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{ret} \PYG{o}{=} \PYG{n}{retriever}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ret}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{obj}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{mymethod} \PYG{c+c1}{\PYGZsh{} register creating method in \PYGZdq{}obj\PYGZdq{}}
\PYG{n}{im} \PYG{o}{=} \PYG{n}{ret}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{obj}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} get object (created obj +1, with reference)}
\PYG{k}{assert} \PYG{n}{im} \PYG{o+ow}{is} \PYG{n}{ret}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{obj}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} check that it gets the same object}
\PYG{c+c1}{\PYGZsh{} it remembers that \PYGZdq{}obj\PYGZdq{} is last registered or fetched object too}
\PYG{k}{assert} \PYG{n}{ret}\PYG{p}{(}\PYG{p}{)} \PYG{o+ow}{is} \PYG{n}{ret}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} lets register with better control (created obj2 +1, no reference)}
\PYG{n}{ret}\PYG{o}{.}\PYG{n}{register}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{obj2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{mymethod}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{mymethod}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} proves that obj2 is not the same as obj (created obj2 +1, no reference)}
\PYG{k}{assert} \PYG{n}{ret}\PYG{p}{(}\PYG{p}{)} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{n}{ret}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{obj}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{k}{print} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{ret}\PYG{o}{.}\PYG{n}{iteritems}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} get items}
\end{Verbatim}

\end{fulllineitems}

\index{resetGetter() (RRtoolbox.lib.cache.resourceManager static method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.resourceManager.resetGetter}\pysiglinewithargsret{\strong{static }\bfcode{resetGetter}}{\emph{getter}}{}
Helper function to reset getter parameters.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{getter}} -- any instance of objectGetter

\end{description}\end{quote}

\end{fulllineitems}

\index{unit (RRtoolbox.lib.cache.resourceManager attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.resourceManager.unit}\pysigline{\bfcode{unit}}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
user defined units

\end{description}\end{quote}

\end{fulllineitems}

\index{units2bytes() (RRtoolbox.lib.cache.resourceManager method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.resourceManager.units2bytes}\pysiglinewithargsret{\bfcode{units2bytes}}{\emph{value}}{}
converts value from user units two bytes

\end{fulllineitems}

\index{usedMemory (RRtoolbox.lib.cache.resourceManager attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.resourceManager.usedMemory}\pysigline{\bfcode{usedMemory}}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
used memory in user units

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{retriever (class in RRtoolbox.lib.cache)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.retriever}\pysigline{\strong{class }\code{RRtoolbox.lib.cache.}\bfcode{retriever}}
Bases: \code{\_abcoll.MutableMapping}

keep track of references and create objects on demand if needed.
\index{register() (RRtoolbox.lib.cache.retriever method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.cache.retriever.register}\pysiglinewithargsret{\bfcode{register}}{\emph{key}, \emph{method=None}, \emph{instance=None}}{}
Register object to retrieve.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{key}} -- hashable key to retrieve

\item {} 
\textbf{\texttt{method}} -- callable method to get object

\item {} 
\textbf{\texttt{instance}} -- object instance already created from method

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{mymethod}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{class} \PYG{n+nc}{constructor}\PYG{p}{:} \PYG{k}{pass}
    \PYG{k}{return} \PYG{n}{constructor}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{ret} \PYG{o}{=} \PYG{n}{retriever}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ret}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{obj}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{mymethod} \PYG{c+c1}{\PYGZsh{} register creating method in \PYGZdq{}obj\PYGZdq{}}
\PYG{n}{im} \PYG{o}{=} \PYG{n}{ret}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{obj}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} get object (created obj +1, with reference)}
\PYG{k}{assert} \PYG{n}{im} \PYG{o+ow}{is} \PYG{n}{ret}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{obj}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} check that it gets the same object}
\PYG{c+c1}{\PYGZsh{} it remembers that \PYGZdq{}obj\PYGZdq{} is last registered or fetched object too}
\PYG{k}{assert} \PYG{n}{ret}\PYG{p}{(}\PYG{p}{)} \PYG{o+ow}{is} \PYG{n}{ret}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} lets register with better control (created obj2 +1, no reference)}
\PYG{n}{ret}\PYG{o}{.}\PYG{n}{register}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{obj2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{mymethod}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{mymethod}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} proves that obj2 is not the same as obj (created obj2 +1, no reference)}
\PYG{k}{assert} \PYG{n}{ret}\PYG{p}{(}\PYG{p}{)} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{n}{ret}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{obj}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{k}{print} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{ret}\PYG{o}{.}\PYG{n}{iteritems}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} get items}
\end{Verbatim}

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{RRtoolbox.lib.config module}
\label{RRtoolbox.lib:module-RRtoolbox.lib.config}\label{RRtoolbox.lib:rrtoolbox-lib-config-module}\index{RRtoolbox.lib.config (module)}\begin{quote}\begin{description}
\item[{platform}] \leavevmode
Unix, Windows

\item[{synopsis}] \leavevmode
Looking for a reference? look here!.

\end{description}\end{quote}

This module contains all config data to the package.
\index{ConfigTool (class in RRtoolbox.lib.config)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.config.ConfigTool}\pysigline{\strong{class }\code{RRtoolbox.lib.config.}\bfcode{ConfigTool}}
Manage the configured Tools.
\index{getTools() (RRtoolbox.lib.config.ConfigTool static method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.config.ConfigTool.getTools}\pysiglinewithargsret{\strong{static }\bfcode{getTools}}{\emph{package}}{}
Obtains the tools of a directory for the RRtoolbox.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{package}} -- path to the directory or package object.

\item[{Returns}] \leavevmode
a dictionary of imported modules.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{directoryManager (class in RRtoolbox.lib.config)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.config.directoryManager}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.config.}\bfcode{directoryManager}}{\emph{path=None}, \emph{raiseError=True}, \emph{autosave=False}}{}
Bases: \code{object}

Manage the configured variables, paths and files.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{path}} -- (None) path to configuration file. If None uses default path.

\item {} 
\textbf{\texttt{raiseError}} -- True to raise when not attribute in ConfigFile.

\item {} 
\textbf{\texttt{autosave}} -- (True) if True saves at each change.

\end{itemize}

\end{description}\end{quote}

\begin{notice}{note}{Note:}
Any attribute that is not in ConfigFile returns None.
Use raiseError to control this behaviour.
\end{notice}
\index{default (RRtoolbox.lib.config.directoryManager attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.config.directoryManager.default}\pysigline{\bfcode{default}}
get directories from dictionary representing environment variables.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
dictionary of directories.

\end{description}\end{quote}

\begin{notice}{note}{Note:}
Only directories in the scope of the module are detected.
\end{notice}

\end{fulllineitems}

\index{load() (RRtoolbox.lib.config.directoryManager method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.config.directoryManager.load}\pysiglinewithargsret{\bfcode{load}}{}{}
loads the configuration file and update.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
loaded configuration file dictionary.

\end{description}\end{quote}

\begin{notice}{warning}{Warning:}
Unsaved instance variables will be replaced by configuration file variables.
\end{notice}

\end{fulllineitems}

\index{reset() (RRtoolbox.lib.config.directoryManager method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.config.directoryManager.reset}\pysiglinewithargsret{\bfcode{reset}}{}{}
Returns the configuration file to default variables.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
False, if error. Dictionary of new data, if successful.

\end{description}\end{quote}

\begin{notice}{warning}{Warning:}
All custom data is lost in configuration file.
\end{notice}

\begin{notice}{warning}{Warning:}
ConfigFile is purposely not updated. Call manually method load()
\end{notice}

\end{fulllineitems}

\index{save() (RRtoolbox.lib.config.directoryManager method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.config.directoryManager.save}\pysiglinewithargsret{\bfcode{save}}{\emph{mode=0}}{}
saves configuration file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{mode}} -- 0- delete and save, 1- update without replace,
2- update replacing variables.

\item[{Returns}] \leavevmode
False, if error. Dictionary of new data, if successful.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{findModules() (in module RRtoolbox.lib.config)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.config.findModules}\pysiglinewithargsret{\code{RRtoolbox.lib.config.}\bfcode{findModules}}{\emph{package}, \emph{exclude=None}}{}
Find modules from a package.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{package}} -- imported packaged or path (str).

\item {} 
\textbf{\texttt{exclude}} -- list of modules to exclude.

\end{itemize}

\item[{Returns}] \leavevmode
dictionary containing importer, ispkg

\end{description}\end{quote}

\end{fulllineitems}

\index{getModules() (in module RRtoolbox.lib.config)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.config.getModules}\pysiglinewithargsret{\code{RRtoolbox.lib.config.}\bfcode{getModules}}{\emph{package}, \emph{exclude=None}}{}
Import modules from a package.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{package}} -- imported packaged or path (str).

\item[{Returns}] \leavevmode
dictionary containing imported modules.

\end{description}\end{quote}

\end{fulllineitems}

\index{getPackagePath() (in module RRtoolbox.lib.config)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.config.getPackagePath}\pysiglinewithargsret{\code{RRtoolbox.lib.config.}\bfcode{getPackagePath}}{\emph{package}}{}
Get the path of a package object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{package}} -- package object or path (str).

\item[{Returns}] \leavevmode
path to the package.

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{RRtoolbox.lib.descriptors module}
\label{RRtoolbox.lib:module-RRtoolbox.lib.descriptors}\label{RRtoolbox.lib:rrtoolbox-lib-descriptors-module}\index{RRtoolbox.lib.descriptors (module)}\index{ASIFT() (in module RRtoolbox.lib.descriptors)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.descriptors.ASIFT}\pysiglinewithargsret{\code{RRtoolbox.lib.descriptors.}\bfcode{ASIFT}}{\emph{*args}, \emph{**kwargs}}{}
asift(feature\_name, img, mask=None, pool=None) -\textgreater{} keypoints, descrs

Apply a set of affine transformations to the image, detect keypoints and
reproject them into initial image coordinates.
See \href{http://www.ipol.im/pub/algo/my\_affine\_sift/}{http://www.ipol.im/pub/algo/my\_affine\_sift/} for the details.

ThreadPool object may be passed to speedup the computation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{feature\_name}} -- feature name to create detector.

\item {} 
\textbf{\texttt{img}} -- image to find keypoints and its descriptors

\item {} 
\textbf{\texttt{mask}} -- mask to detect keypoints (it uses default, mask{[}:{]} = 255)

\item {} 
\textbf{\texttt{pool}} -- multiprocessing pool (dummy, it uses multithreading)

\end{itemize}

\item[{Returns}] \leavevmode
keypoints,descriptors

\end{description}\end{quote}

\end{fulllineitems}

\index{ASIFT\_iter() (in module RRtoolbox.lib.descriptors)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.descriptors.ASIFT_iter}\pysiglinewithargsret{\code{RRtoolbox.lib.descriptors.}\bfcode{ASIFT\_iter}}{\emph{imgs}, \emph{feature\_name='sift-flann'}}{}
Affine-SIFT for N images.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{imgs}} -- images to apply asift

\item {} 
\textbf{\texttt{feature\_name}} -- eg. SIFT SURF ORB

\end{itemize}

\item[{Returns}] \leavevmode
{[}(kp1,desc1),...,(kpN,descN){]}

\end{description}\end{quote}

\end{fulllineitems}

\index{ASIFT\_multiple() (in module RRtoolbox.lib.descriptors)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.descriptors.ASIFT_multiple}\pysiglinewithargsret{\code{RRtoolbox.lib.descriptors.}\bfcode{ASIFT\_multiple}}{\emph{imgs}, \emph{feature\_name='sift-flann'}}{}
Affine-SIFT for N images.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{imgs}} -- images to apply asift

\item {} 
\textbf{\texttt{feature\_name}} -- eg. SIFT SURF ORB

\end{itemize}

\item[{Returns}] \leavevmode
{[}(kp1,desc1),...,(kpN,descN){]}

\end{description}\end{quote}

\end{fulllineitems}

\index{Feature (class in RRtoolbox.lib.descriptors)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.descriptors.Feature}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.descriptors.}\bfcode{Feature}}{\emph{pool=\textless{}multiprocessing.pool.ThreadPool object\textgreater{}}, \emph{useASIFT=True}, \emph{debug=True}}{}
Bases: \code{object}

Class to manage detection and computation of features
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{pool}} -- multiprocessing pool (dummy, it uses multithreading)

\item {} 
\textbf{\texttt{useASIFT}} -- if True adds Affine perspectives to the detector.

\item {} 
\textbf{\texttt{debug}} -- if True prints to the stdout debug messages.

\end{itemize}

\end{description}\end{quote}
\index{config() (RRtoolbox.lib.descriptors.Feature method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.descriptors.Feature.config}\pysiglinewithargsret{\bfcode{config}}{\emph{name}, \emph{separator='-`}}{}
This function takes parameters from a command to initialize a detector and matcher.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{name}} -- ``{[}a-{]}\textless{}sift\textbar{}surf\textbar{}orb\textgreater{}{[}-flann{]}'' (str) Ex: ``a-sift-flann''

\item {} 
\textbf{\texttt{features}} -- it is a dictionary containing the mapping from name to the
initialized detector, matcher pair. If None it is created.
This feature is to reduce time by reusing created features.

\end{itemize}

\item[{Returns}] \leavevmode
detector, matcher

\end{description}\end{quote}

\end{fulllineitems}

\index{detectAndCompute() (RRtoolbox.lib.descriptors.Feature method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.descriptors.Feature.detectAndCompute}\pysiglinewithargsret{\bfcode{detectAndCompute}}{\emph{img}, \emph{mask=None}}{}
detect keypoints and descriptors
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{img}} -- image to find keypoints and its descriptors

\item {} 
\textbf{\texttt{mask}} -- mask to detect keypoints (it uses default, mask{[}:{]} = 255)

\end{itemize}

\item[{Returns}] \leavevmode
keypoints,descriptors

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{MATCH() (in module RRtoolbox.lib.descriptors)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.descriptors.MATCH}\pysiglinewithargsret{\code{RRtoolbox.lib.descriptors.}\bfcode{MATCH}}{\emph{*args}, \emph{**kwargs}}{}
Use matcher and asift output to obtain Transformation matrix (TM).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{feature\_name}} -- feature name to create detector. It is the same used in the detector
which is used in init\_feature function but the detector itself is ignored.
e.g. if `detector' uses BFMatcher, if `detector-flann' uses FlannBasedMatcher.

\item {} 
\textbf{\texttt{kp1}} -- keypoints of source image

\item {} 
\textbf{\texttt{desc1}} -- descriptors of kp1

\item {} 
\textbf{\texttt{kp2}} -- keypoints of destine image

\item {} 
\textbf{\texttt{desc2}} -- descriptors of kp2

\end{itemize}

\item[{Returns}] \leavevmode
TM

\end{description}\end{quote}

\# \href{http://docs.opencv.org/3.0-beta/doc/py\_tutorials/py\_feature2d/py\_feature\_homography/py\_feature\_homography.html}{http://docs.opencv.org/3.0-beta/doc/py\_tutorials/py\_feature2d/py\_feature\_homography/py\_feature\_homography.html}

\end{fulllineitems}

\index{MATCH\_multiple() (in module RRtoolbox.lib.descriptors)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.descriptors.MATCH_multiple}\pysiglinewithargsret{\code{RRtoolbox.lib.descriptors.}\bfcode{MATCH\_multiple}}{\emph{pairlist}, \emph{feature\_name='sift-flann'}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{pairlist}} -- list of keypoint and descriptors pair e.g. {[}(kp1,desc1),...,(kpN,descN){]}

\item {} 
\textbf{\texttt{feature\_name}} -- feature name to create detector

\end{itemize}

\item[{Returns}] \leavevmode
{[}(H1, mask1, kp\_pairs1),....(HN, maskN, kp\_pairsN){]}

\end{description}\end{quote}

\end{fulllineitems}

\index{affine\_skew() (in module RRtoolbox.lib.descriptors)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.descriptors.affine_skew}\pysiglinewithargsret{\code{RRtoolbox.lib.descriptors.}\bfcode{affine\_skew}}{\emph{tilt}, \emph{phi}, \emph{img}, \emph{mask=None}}{}
Increase robustness to descriptors by calculating other invariant perspectives to image.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{tilt}} -- tilting of image

\item {} 
\textbf{\texttt{phi}} -- rotation of image (in degrees)

\item {} 
\textbf{\texttt{img}} -- image to find Affine transforms

\item {} 
\textbf{\texttt{mask}} -- mask to detect keypoints (it uses default, mask{[}:{]} = 255)

\end{itemize}

\item[{Returns}] \leavevmode
skew\_img, skew\_mask, Ai (invert Affine Transform)

\end{description}\end{quote}

Ai - is an affine transform matrix from skew\_img to img

\end{fulllineitems}

\index{filter\_matches() (in module RRtoolbox.lib.descriptors)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.descriptors.filter_matches}\pysiglinewithargsret{\code{RRtoolbox.lib.descriptors.}\bfcode{filter\_matches}}{\emph{kp1}, \emph{kp2}, \emph{matches}, \emph{ratio=0.75}}{}
This function applies a ratio test.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{kp1}} -- raw keypoints 1

\item {} 
\textbf{\texttt{kp2}} -- raw keypoints 2

\item {} 
\textbf{\texttt{matches}} -- raw matches

\item {} 
\textbf{\texttt{ratio}} -- filtering ratio of distance

\end{itemize}

\item[{Returns}] \leavevmode
filtered keypoint 1, filtered keypoint 2, keypoint pairs

\end{description}\end{quote}

\end{fulllineitems}

\index{init\_feature() (in module RRtoolbox.lib.descriptors)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.descriptors.init_feature}\pysiglinewithargsret{\code{RRtoolbox.lib.descriptors.}\bfcode{init\_feature}}{\emph{name}, \emph{features=None}}{}
This function takes parameters from a command to initialize a detector and matcher.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{name}} -- ``\textless{}sift\textbar{}surf\textbar{}orb\textgreater{}{[}-flann{]}'' (str) Ex: ``sift-flann''

\item {} 
\textbf{\texttt{features}} -- it is a dictionary containing the mapping from name to the
initialized detector, matcher pair. If None it is created.
This feature is to reduce time by reusing created features.

\end{itemize}

\item[{Returns}] \leavevmode
detector, matcher

\end{description}\end{quote}

\end{fulllineitems}

\index{inlineRatio() (in module RRtoolbox.lib.descriptors)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.descriptors.inlineRatio}\pysiglinewithargsret{\code{RRtoolbox.lib.descriptors.}\bfcode{inlineRatio}}{\emph{inlines}, \emph{lines}, \emph{thresh=30}}{}
Probability that a match was correct.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{inlines}} -- number of matched lines

\item {} 
\textbf{\texttt{lines}} -- number lines

\item {} 
\textbf{\texttt{thresh}} -- threshold for lines (i.e. very low probability \textless{}= thresh \textless{} good probability)

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{RRtoolbox.lib.directory module}
\label{RRtoolbox.lib:module-RRtoolbox.lib.directory}\label{RRtoolbox.lib:rrtoolbox-lib-directory-module}\index{RRtoolbox.lib.directory (module)}
This module holds all path manipulation methods and a string concept called directory (referenced paths and strings)
designed to support \code{config} and be used with \code{session}.


\paragraph{keywords:}
\label{RRtoolbox.lib:keywords}
\emph{path}: it can be to a folder or file or url if specified
\emph{filename}: the file name without its path
\emph{filepath}: the path to a file
\emph{dirname}: the path to a folder
\emph{url}: Universal Resource Locator
\index{FileDirectory (class in RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.FileDirectory}\pysigline{\strong{class }\code{RRtoolbox.lib.directory.}\bfcode{FileDirectory}}
Bases: {\hyperref[RRtoolbox.lib:RRtoolbox.lib.directory.directory]{\emph{\code{RRtoolbox.lib.directory.directory}}}}

Saves contents of a file as with directories.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} -- list, directory instance, dictionary or string.

\item {} 
\textbf{\texttt{filename}} -- name of file.

\item {} 
\textbf{\texttt{path}} -- path to folder where file is (it must finish in /).

\item {} 
\textbf{\texttt{notes}} -- optional description string

\item {} 
\textbf{\texttt{kwargs}} -- additional data to add in directory.

\end{itemize}

\end{description}\end{quote}
\index{makeFile() (RRtoolbox.lib.directory.FileDirectory method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.FileDirectory.makeFile}\pysiglinewithargsret{\bfcode{makeFile}}{}{}
Makes a file with its contents to path/filename.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
True if successful

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{changedir() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.changedir}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{changedir}}{\emph{filepath}, \emph{dirname}, \emph{ext=True}}{}
Change path to file with dirname.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{filepath}} -- path to file.

\item {} 
\textbf{\texttt{dirname}} -- new path to replace in filepath.

\item {} 
\textbf{\texttt{ext}} -- True to keep extension of file if any.

\end{itemize}

\item[{Returns}] \leavevmode
directory object of changed path.

\end{description}\end{quote}

\end{fulllineitems}

\index{checkDir() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.checkDir}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{checkDir}}{\emph{dirname}}{}
checks if dirname exists.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{dirname}} -- path to folder

\item[{Returns}] \leavevmode
True if exits, False if not

\end{description}\end{quote}

\end{fulllineitems}

\index{checkFile() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.checkFile}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{checkFile}}{\emph{path}}{}
checks if filepath or filename exists.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{path}} -- filepath or filename

\item[{Returns}] \leavevmode
True if exits, False if not

\end{description}\end{quote}

\end{fulllineitems}

\index{checkPath() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.checkPath}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{checkPath}}{\emph{path}}{}
checks if path exists.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{path}} -- path to folder or file.

\item[{Returns}] \leavevmode
True if exits, False if not

\end{description}\end{quote}

\end{fulllineitems}

\index{checkURL() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.checkURL}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{checkURL}}{\emph{url}}{}
checks if url exists.
:param url: path to url
:return: True if exits, False if not

\end{fulllineitems}

\index{correctPath() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.correctPath}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{correctPath}}{\emph{path}, \emph{relative}}{}
Get path corrected from its relative path or level index.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{path}} -- path or file name.

\item {} 
\textbf{\texttt{relative}} -- pattern or level in directory.

\end{itemize}

\item[{Returns}] \leavevmode
corrected path.

\end{description}\end{quote}

\end{fulllineitems}

\index{correctSep() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.correctSep}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{correctSep}}{\emph{path='/mnt/4E443F99443F82AF/Dropbox/PYTHON/RRtools/RRtoolbox/lib/directory.pyc'}, \emph{separator='/'}}{}
Replaces the path separators by custom or OS standard separator.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{path}} -- relative or absolute path (str). Default is \_\_file\_\_ or module's path.

\item {} 
\textbf{\texttt{separator}} -- desired separators, By default uses system separator (os.path.sep).

\end{itemize}

\item[{Returns}] \leavevmode
path with corrected separator.

\end{description}\end{quote}

\end{fulllineitems}

\index{decoratePath() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.decoratePath}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{decoratePath}}{\emph{relative}, \emph{sep='/'}}{}
Decorated path is controlled to give absolute path from relative path.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{relative}} -- int or path.

\item {} 
\textbf{\texttt{sep}} -- path separator

\end{itemize}

\item[{Returns}] \leavevmode
decorator

\end{description}\end{quote}

\end{fulllineitems}

\index{directory (class in RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.directory}\pysigline{\strong{class }\code{RRtoolbox.lib.directory.}\bfcode{directory}}
Bases: \code{str}

semi-mutable string representation of a inmutable string with support for path representations.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} -- list, directory instance, dictionary or string.

\item {} 
\textbf{\texttt{ispath}} -- True to add support for paths.

\item {} 
\textbf{\texttt{copy}} -- when data is a directory if copy is True then this instance data is independent
of the passed directory otherwise both directories are a reference to the same
dictionary data but they are not the same object.

\item {} 
\textbf{\texttt{kwargs}} -- additional data to add in directory.

\end{itemize}

\end{description}\end{quote}
\index{copy() (RRtoolbox.lib.directory.directory method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.directory.copy}\pysiglinewithargsret{\bfcode{copy}}{}{}
Creates copy of itself.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
non-referenced directory copy.

\end{description}\end{quote}

\end{fulllineitems}

\index{correctSTRBuiltin() (RRtoolbox.lib.directory.directory method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.directory.correctSTRBuiltin}\pysiglinewithargsret{\bfcode{correctSTRBuiltin}}{}{}
Decorate all the built-in functions of class directory.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
built-in decorated function.

\end{description}\end{quote}

\end{fulllineitems}

\index{filterdata() (RRtoolbox.lib.directory.directory static method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.directory.filterdata}\pysiglinewithargsret{\strong{static }\bfcode{filterdata}}{\emph{data}, \emph{ispath=None}, \emph{kwargs=None}}{}
Adequate data for dictionary creation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} -- any supported object.

\item {} 
\textbf{\texttt{ispath}} -- True to add support for paths.

\item {} 
\textbf{\texttt{kwargs}} -- additional data to add in directory.

\end{itemize}

\item[{Returns}] \leavevmode
dictionary

\end{description}\end{quote}

\end{fulllineitems}

\index{repr2list() (RRtoolbox.lib.directory.directory static method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.directory.repr2list}\pysiglinewithargsret{\strong{static }\bfcode{repr2list}}{\emph{data}, \emph{level=0}}{}
Converts the representation of a directory.repr to pickleable.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{data}} -- directory.repr of the form {[}''string'',directory,...,directory.repr{]}.

\item[{Returns}] \leavevmode
pickleable list.

\end{description}\end{quote}

\end{fulllineitems}

\index{repr2str() (RRtoolbox.lib.directory.directory static method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.directory.repr2str}\pysiglinewithargsret{\strong{static }\bfcode{repr2str}}{\emph{data}, \emph{ispath=True}}{}
Converts the representation of a directory.repr to string.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{data}} -- directory.repr of the form {[}''string'',directory,...,directory.repr{]}.

\item[{Returns}] \leavevmode
converted string.

\end{description}\end{quote}

\end{fulllineitems}

\index{update() (RRtoolbox.lib.directory.directory method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.directory.update}\pysiglinewithargsret{\bfcode{update}}{\emph{data=None}}{}
Return an updated copy with provided data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{data}} -- any supported object.
If None return updated and referenced copy of itself.

\item[{Returns}] \leavevmode
new directory referenced to itself.

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_left() (RRtoolbox.lib.directory.directory method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.directory.update_left}\pysiglinewithargsret{\bfcode{update\_left}}{\emph{other}}{}
Updates representation a the left.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} -- any supported object.

\item[{Returns}] \leavevmode
new directory referenced to itself.

\end{description}\end{quote}

\begin{notice}{note}{Note:}
Equivalent to self - other e.g. directory({[}other, self{]})
\end{notice}

\end{fulllineitems}

\index{update\_right() (RRtoolbox.lib.directory.directory method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.directory.update_right}\pysiglinewithargsret{\bfcode{update\_right}}{\emph{other}}{}
Updates representation a the right.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} -- any supported object.

\item[{Returns}] \leavevmode
new directory referenced to itself.

\end{description}\end{quote}

\begin{notice}{note}{Note:}
Equivalent to self + other e.g. directory({[}self, other{]})
\end{notice}

\end{fulllineitems}


\end{fulllineitems}

\index{getData() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.getData}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{getData}}{\emph{path='/mnt/4E443F99443F82AF/Dropbox/PYTHON/RRtools/RRtoolbox/lib/directory.pyc'}}{}
Get standard path from path.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{path}} -- it can be to a folder or file. Default is \_\_file\_\_ or module's path.

\item[{Returns}] \leavevmode
{[}drive,dirname,filename,ext{]}.
1. drive or UNC (Universal Naming Convention)
2. dirname is path to folder.
3. filename is name of file.
4. ext is extension of file.

\end{description}\end{quote}

\end{fulllineitems}

\index{getFileHandle() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.getFileHandle}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{getFileHandle}}{\emph{path}}{}
Gets a file handle from url or disk file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{path}} -- filepath or url

\item[{Returns}] \leavevmode
file object

\end{description}\end{quote}

\end{fulllineitems}

\index{getFileSize() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.getFileSize}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{getFileSize}}{\emph{path}}{}
Gets a size from url or disk file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{path}} -- filepath or url

\item[{Returns}] \leavevmode
size in bytes

\end{description}\end{quote}

\end{fulllineitems}

\index{getPath() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.getPath}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{getPath}}{\emph{path='/mnt/4E443F99443F82AF/Dropbox/PYTHON/RRtools/RRtoolbox/lib/directory.pyc'}}{}
Get standard path from path.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{path}} -- it can be to a folder or file. Default is \_\_file\_\_ or module's path.
If file exists it selects its folder.

\item[{Returns}] \leavevmode
dirname (path to a folder)

\end{description}\end{quote}

\begin{notice}{note}{Note:}
It is the same as os.path.dirname(os.path.abspath(path)).
\end{notice}

\end{fulllineitems}

\index{getSep() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.getSep}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{getSep}}{\emph{path}, \emph{pattern='/\textbackslash{}\textbackslash{}'}}{}
Get path separator or indicator.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{path}} -- relative or absolute path (str).

\item {} 
\textbf{\texttt{pattern}} -- guess characters to compare path (str).

\end{itemize}

\item[{Returns}] \leavevmode
sep (str).

\end{description}\end{quote}

\begin{notice}{note}{Note:}
It is equivalent to os.path.sep but obtained from the given path and patterns.
\end{notice}

\end{fulllineitems}

\index{getShortenedPath() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.getShortenedPath}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{getShortenedPath}}{\emph{path}, \emph{comp}}{}
Path is controlled to give absolute path from relative path or integer.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{path}} -- absolute path (str).

\item {} 
\textbf{\texttt{comp}} -- pattern or relative path (str) or integer representing level of folder
determined by the separator Ex. ``/level 1/level 2/.../level N or -1''.

\end{itemize}

\item[{Returns}] \leavevmode
path before matched to comp  Ex: ``C://level 1//comp --\textgreater{} C://level 1''

\end{description}\end{quote}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{path} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LEVEL1/LEVEL2/LEVEL3/LEVEL4/LEVEL5}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{getShortenedPath}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} minus two levels}
\PYG{g+go}{LEVEL1/LEVEL2/LEVEL3}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{getShortenedPath}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} until three levels}
\PYG{g+go}{LEVEL1/LEVEL2}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{getShortenedPath}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LEVEL1/LEVEL2/LEVEL3/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{LEVEL1/LEVEL2/LEVEL3/}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{getShortenedPath}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LEVEL4/REPLACE5/NEWLEVEL}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{LEVEL1/LEVEL2/LEVEL3/LEVEL4/REPLACE5/NEWLEVEL}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{getShortenedPath}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../../SHOULD\PYGZus{}BE\PYGZus{}LEVEL4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{LEVEL1/LEVEL2/LEVEL3/SHOULD\PYGZus{}BE\PYGZus{}LEVEL4}
\end{Verbatim}

\end{fulllineitems}

\index{getSplitted() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.getSplitted}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{getSplitted}}{\emph{path='/mnt/4E443F99443F82AF/Dropbox/PYTHON/RRtools/RRtoolbox/lib/directory.pyc'}}{}
Splits a file path by its separators.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{path}} -- it can be to a folder or file. Default is \_\_file\_\_ or module's path.

\item[{Returns}] \leavevmode
splitted path.

\end{description}\end{quote}

\end{fulllineitems}

\index{increment\_if\_exits() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.increment_if_exits}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{increment\_if\_exits}}{\emph{fn}, \emph{add='\_\{num\}'}}{}
Generates new name if it exits.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{fn}} -- absolute path or filename

\item {} 
\textbf{\texttt{add}} -- if fn exists add pattern

\end{itemize}

\item[{Returns}] \leavevmode
un-existent fn

\end{description}\end{quote}

\end{fulllineitems}

\index{joinPath() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.joinPath}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{joinPath}}{\emph{absolute}, \emph{relative}}{}
Joins an absolute path to a relative path.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{absolute}} -- directory or path.

\item {} 
\textbf{\texttt{relative}} -- directory or path.

\end{itemize}

\item[{Returns}] \leavevmode
joined path.

\end{description}\end{quote}

\begin{notice}{note}{Note:}
It is equivalent to os.path.join but works with directories.
\end{notice}

\end{fulllineitems}

\index{mkPath() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.mkPath}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{mkPath}}{\emph{path}}{}
Make path (i.e. creating folder) for filepath.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{path}} -- path to nonexistent folder or file.

\item[{Returns}] \leavevmode
created path.

\end{description}\end{quote}

\end{fulllineitems}

\index{quickOps() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.quickOps}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{quickOps}}{\emph{path}, \emph{comp}}{}
(IN DEVELOPMENT) make quick matching operations in path.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{path}} -- path to folder

\item {} 
\textbf{\texttt{comp}} -- pattern

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

Requirements:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{path} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LEVEL1/LEVEL2/LEVEL3/LEVEL4/LEVEL5}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{print} \PYG{n}{quickOps}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../ROOT/../LEVEL1/../LEVEL2/LEVEL3/../../LEVEL4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LEVEL4}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{print} \PYG{n}{quickOps}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ROOT/../LEVEL1/LEVEL2/../../LEVEL4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LEVEL3/LEVEL4}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{print} \PYG{n}{quickOps}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../LEVEL2/../}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LEVEL1/LEVEL3/LEVEL4/LEVEL5}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{print} \PYG{n}{quickOps}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../LEVEL2/..}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LEVEL1/LEVEL3/LEVEL4/LEVEL5/}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{print} \PYG{n}{quickOps}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LEVEL2/../../LEVEL4/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LEVEL2/LEVEL3/LEVEL4/}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{print} \PYG{n}{quickOps}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ROOT/../LEVEL2/../../LEVEL4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ROOT/LEVEL3/LEVEL4}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{print} \PYG{n}{quickOps}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LEVEL\PYGZhy{}1/../NEW7/LEVEL8}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LEVEL\PYGZhy{}1/LEVEL1/LEVEL2/LEVEL3/LEVEL4/LEVEL5/NEW7/LEVEL8}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{print}
\end{Verbatim}

\end{fulllineitems}

\index{rmFile() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.rmFile}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{rmFile}}{\emph{filepath}}{}
Remove file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{filepath}} -- path to file.

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{rmPath() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.rmPath}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{rmPath}}{\emph{path}, \emph{ignore\_errors=False}, \emph{onerror=None}}{}
Remove path from path.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{path}} -- path to nonexistent folder or file.

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}


\strong{See also:}


shutil.rmtree



\end{fulllineitems}

\index{strdifference() (in module RRtoolbox.lib.directory)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.directory.strdifference}\pysiglinewithargsret{\code{RRtoolbox.lib.directory.}\bfcode{strdifference}}{\emph{s1}, \emph{s2}}{}
Get string differences.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{s1}} -- string 1

\item {} 
\textbf{\texttt{s2}} -- string 2

\end{itemize}

\item[{Returns}] \leavevmode
(splitted string 1, splitted string 2, index).
A splitted string is a list with the string parts.
Index is a list containing the indexes of different parts of the two splitted strings.

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{RRtoolbox.lib.image module}
\label{RRtoolbox.lib:rrtoolbox-lib-image-module}

\subsubsection{RRtoolbox.lib.inspector module}
\label{RRtoolbox.lib:module-RRtoolbox.lib.inspector}\label{RRtoolbox.lib:rrtoolbox-lib-inspector-module}\index{RRtoolbox.lib.inspector (module)}
This module is an all purpose intended for debugging, tracking, auto-documenting and self-introspecting the
package

Made by Davtoh. Powered partially by pycallgraph.
Dependent project: \href{https://github.com/gak/pycallgraph/\#python-call-graph}{https://github.com/gak/pycallgraph/\#python-call-graph}
\index{Asyncronous (class in RRtoolbox.lib.inspector)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.Asyncronous}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.inspector.}\bfcode{Asyncronous}}{\emph{outputs}, \emph{config}}{}
Bases: {\hyperref[RRtoolbox.lib:RRtoolbox.lib.inspector.Syncronous]{\emph{\code{RRtoolbox.lib.inspector.Syncronous}}}}
\index{done() (RRtoolbox.lib.inspector.Asyncronous method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.Asyncronous.done}\pysiglinewithargsret{\bfcode{done}}{}{}
\end{fulllineitems}

\index{start() (RRtoolbox.lib.inspector.Asyncronous method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.Asyncronous.start}\pysiglinewithargsret{\bfcode{start}}{}{}
\end{fulllineitems}

\index{tracer() (RRtoolbox.lib.inspector.Asyncronous method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.Asyncronous.tracer}\pysiglinewithargsret{\bfcode{tracer}}{\emph{frame}, \emph{event}, \emph{arg}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{Logger (class in RRtoolbox.lib.inspector)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.Logger}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.inspector.}\bfcode{Logger}}{\emph{**kwargs}}{}
Bases: \code{object}

Logger for decorated functions. Holds important information of an instanced object and
can be used with @trace decorator for traceback purposes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{func}} -- object reference.

\item {} 
\textbf{\texttt{funcname}} -- object name.

\item {} 
\textbf{\texttt{inputs}} -- inputs pass to the object.

\item {} 
\textbf{\texttt{outputs}} -- outputs given by the object execution.

\item {} 
\textbf{\texttt{time}} -- initial time of execution.

\item {} 
\textbf{\texttt{exectime}} -- time of execution in seconds.

\item {} 
\textbf{\texttt{writer}} -- writer function where messages are passed.

\item {} 
\textbf{\texttt{eventHandle}} -- event function where object is
passed when Logger.broadcast() is called.

\item {} 
\textbf{\texttt{msg\_report}} -- message format to use in reports.

\item {} 
\textbf{\texttt{msg\_no\_executed}} -- massage format to pass to writer when object
has not been executed and Logger.report() is called.

\item {} 
\textbf{\texttt{msg\_executed}} -- massage format to use when object is
executed and Logger.broadcast() is called.

\end{itemize}

\end{description}\end{quote}
\index{Time\_ (RRtoolbox.lib.inspector.Logger attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.Logger.Time_}\pysigline{\bfcode{Time\_}}
returns formated time (str)

\end{fulllineitems}

\index{Type\_ (RRtoolbox.lib.inspector.Logger attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.Logger.Type_}\pysigline{\bfcode{Type\_}}
returns type name (str)

\end{fulllineitems}

\index{broadcast() (RRtoolbox.lib.inspector.Logger method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.Logger.broadcast}\pysiglinewithargsret{\bfcode{broadcast}}{}{}
pass a notification message on object execution to the writer

\end{fulllineitems}

\index{eventHandle (RRtoolbox.lib.inspector.Logger attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.Logger.eventHandle}\pysigline{\bfcode{eventHandle}\strong{ = None}}
\end{fulllineitems}

\index{file (RRtoolbox.lib.inspector.Logger attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.Logger.file}\pysigline{\bfcode{file}\strong{ = \textless{}open file `\textless{}stdout\textgreater{}', mode `w'\textgreater{}}}
\end{fulllineitems}

\index{renew() (RRtoolbox.lib.inspector.Logger method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.Logger.renew}\pysiglinewithargsret{\bfcode{renew}}{}{}
renew Instance

\end{fulllineitems}

\index{report() (RRtoolbox.lib.inspector.Logger method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.Logger.report}\pysiglinewithargsret{\bfcode{report}}{}{}
pass a report of the last executed object to the writer

\end{fulllineitems}

\index{throwError() (RRtoolbox.lib.inspector.Logger method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.Logger.throwError}\pysiglinewithargsret{\bfcode{throwError}}{}{}
throw caught error
:return:

\end{fulllineitems}

\index{tracer (RRtoolbox.lib.inspector.Logger attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.Logger.tracer}\pysigline{\bfcode{tracer}}
\end{fulllineitems}

\index{writer() (RRtoolbox.lib.inspector.Logger method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.Logger.writer}\pysiglinewithargsret{\bfcode{writer}}{\emph{sender}, \emph{*arg}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{Syncronous (class in RRtoolbox.lib.inspector)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.Syncronous}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.inspector.}\bfcode{Syncronous}}{\emph{outputs}, \emph{config}}{}
Bases: \code{pycallgraph.tracer.SyncronousTracer}
\index{start() (RRtoolbox.lib.inspector.Syncronous method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.Syncronous.start}\pysiglinewithargsret{\bfcode{start}}{}{}
\end{fulllineitems}

\index{stop() (RRtoolbox.lib.inspector.Syncronous method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.Syncronous.stop}\pysiglinewithargsret{\bfcode{stop}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{funcData() (in module RRtoolbox.lib.inspector)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.funcData}\pysiglinewithargsret{\code{RRtoolbox.lib.inspector.}\bfcode{funcData}}{\emph{func}}{}
\end{fulllineitems}

\index{graphTrace (class in RRtoolbox.lib.inspector)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.graphTrace}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.inspector.}\bfcode{graphTrace}}{\emph{output=None}, \emph{config=None}}{}
Bases: \code{pycallgraph.pycallgraph.PyCallGraph}
\index{get\_tracer\_class() (RRtoolbox.lib.inspector.graphTrace method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.graphTrace.get_tracer_class}\pysiglinewithargsret{\bfcode{get\_tracer\_class}}{}{}
\end{fulllineitems}

\index{saveSource() (RRtoolbox.lib.inspector.graphTrace method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.graphTrace.saveSource}\pysiglinewithargsret{\bfcode{saveSource}}{\emph{file}}{}
\end{fulllineitems}

\index{source (RRtoolbox.lib.inspector.graphTrace attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.graphTrace.source}\pysigline{\bfcode{source}}
\end{fulllineitems}


\end{fulllineitems}

\index{graphTraceOutput (class in RRtoolbox.lib.inspector)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.graphTraceOutput}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.inspector.}\bfcode{graphTraceOutput}}{\emph{source=None}, \emph{saveflag=True}, \emph{label='`}, \emph{**kwargs}}{}
Bases: \code{pycallgraph.output.graphviz.GraphvizOutput}
\index{done() (RRtoolbox.lib.inspector.graphTraceOutput method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.graphTraceOutput.done}\pysiglinewithargsret{\bfcode{done}}{}{}
\end{fulllineitems}

\index{save() (RRtoolbox.lib.inspector.graphTraceOutput method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.graphTraceOutput.save}\pysiglinewithargsret{\bfcode{save}}{\emph{file=None}, \emph{source=None}}{}
\end{fulllineitems}

\index{saveSource() (RRtoolbox.lib.inspector.graphTraceOutput method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.graphTraceOutput.saveSource}\pysiglinewithargsret{\bfcode{saveSource}}{\emph{file}, \emph{source=None}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{load() (in module RRtoolbox.lib.inspector)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.load}\pysiglinewithargsret{\code{RRtoolbox.lib.inspector.}\bfcode{load}}{\emph{mod\_name}, \emph{obj\_name}}{}
Convert a string version of a class name to the object.

For example, get\_class(`sympy.core.Basic') will return
class Basic located in module sympy.core

\end{fulllineitems}

\index{reloadFunc() (in module RRtoolbox.lib.inspector)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.reloadFunc}\pysiglinewithargsret{\code{RRtoolbox.lib.inspector.}\bfcode{reloadFunc}}{\emph{func}}{}
\end{fulllineitems}

\index{tracer() (in module RRtoolbox.lib.inspector)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.inspector.tracer}\pysiglinewithargsret{\code{RRtoolbox.lib.inspector.}\bfcode{tracer}}{\emph{instance}, \emph{broadcast=True}, \emph{report=True}}{}
Tracer for decorated functions.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{instance}} -- Logger instance

\item {} 
\textbf{\texttt{broadcast}} -- 

\item {} 
\textbf{\texttt{report}} -- 

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{RRtoolbox.lib.plotter module}
\label{RRtoolbox.lib:module-RRtoolbox.lib.plotter}\label{RRtoolbox.lib:rrtoolbox-lib-plotter-module}\index{RRtoolbox.lib.plotter (module)}
This module holds the plotting and data-visualization tools. Motto: don't know how it is interpreted? i'll show you!

\#plotim example
filename = ``t2.jpg''
win = ``test''
img = cv2.resize(cv2.imread(filename), (400, 400))  \# (height, width)
plot = plotim(win,img)
plot.show()
\index{background() (in module RRtoolbox.lib.plotter)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.background}\pysiglinewithargsret{\code{RRtoolbox.lib.plotter.}\bfcode{background}}{\emph{color}, \emph{x=1}, \emph{y=1}, \emph{flag=0}}{}
Creates background rectangle.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{color}} -- main color.

\item {} 
\textbf{\texttt{x}} -- x pixels in axis x.

\item {} 
\textbf{\texttt{y}} -- y pixels in axis y.

\item {} 
\textbf{\texttt{flag}} -- Not implemented.

\end{itemize}

\item[{Returns}] \leavevmode
image of shape y,x and ndim == color.ndim.

\end{description}\end{quote}

\end{fulllineitems}

\index{convert2bgr() (in module RRtoolbox.lib.plotter)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.convert2bgr}\pysiglinewithargsret{\code{RRtoolbox.lib.plotter.}\bfcode{convert2bgr}}{\emph{src}, \emph{bgrcolor=None}}{}
Tries to convert any image format to BGR.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{src}} -- source image.

\item {} 
\textbf{\texttt{bgrcolor}} -- background or transparent color.

\end{itemize}

\item[{Returns}] \leavevmode
BGR array image.

\end{description}\end{quote}

\end{fulllineitems}

\index{convert2bgra() (in module RRtoolbox.lib.plotter)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.convert2bgra}\pysiglinewithargsret{\code{RRtoolbox.lib.plotter.}\bfcode{convert2bgra}}{\emph{src}, \emph{bgracolor=None}, \emph{transparency=None}}{}
Tries to convert any image format to BGRA.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{src}} -- source image.

\item {} 
\textbf{\texttt{bgracolor}} -- background or transparent color.

\item {} 
\textbf{\texttt{transparency}} -- mask or A channel.
(typically source image has not A channel, so user can provide it)

\end{itemize}

\item[{Returns}] \leavevmode
BGRA array image.

\end{description}\end{quote}

\end{fulllineitems}

\index{echo() (in module RRtoolbox.lib.plotter)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.echo}\pysiglinewithargsret{\code{RRtoolbox.lib.plotter.}\bfcode{echo}}{\emph{obj}}{}
Printer (used when user wants to print an object from plotim)
:param obj: object

\end{fulllineitems}

\index{edger (class in RRtoolbox.lib.plotter)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.edger}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.plotter.}\bfcode{edger}}{\emph{img}, \emph{isSIZE=True}, \emph{isEQUA=False}, \emph{isCLAHE=False}, \emph{isBFILTER=False}}{}
Bases: {\hyperref[RRtoolbox.lib:RRtoolbox.lib.plotter.plotim]{\emph{\code{RRtoolbox.lib.plotter.plotim}}}}

Test visualization for edges

self.edge -\textgreater{} the edges in processed image
self.img -\textgreater{} the processed image
self.sample -\textgreater{} the rendered precessed image
\index{computeAll() (RRtoolbox.lib.plotter.edger method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.edger.computeAll}\pysiglinewithargsret{\bfcode{computeAll}}{}{}
\end{fulllineitems}

\index{computeEdge() (RRtoolbox.lib.plotter.edger method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.edger.computeEdge}\pysiglinewithargsret{\bfcode{computeEdge}}{}{}
\end{fulllineitems}

\index{getParameters() (RRtoolbox.lib.plotter.edger method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.edger.getParameters}\pysiglinewithargsret{\bfcode{getParameters}}{\emph{params=(`d'}, \emph{`sigmaColor'}, \emph{`sigmaSpace'}, \emph{`clipLimit'}, \emph{`tileGridSize'}, \emph{`isSIZE'}, \emph{`isEQUA'}, \emph{`isCLAHE'}, \emph{`isBFILTER'}, \emph{`th1'}, \emph{`th2'}, \emph{`size'}, \emph{`apertureSize'}, \emph{`L2gradient')}}{}
\end{fulllineitems}

\index{isActiveWindow() (RRtoolbox.lib.plotter.edger method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.edger.isActiveWindow}\pysiglinewithargsret{\bfcode{isActiveWindow}}{}{}
\end{fulllineitems}

\index{isBFILTER (RRtoolbox.lib.plotter.edger attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.edger.isBFILTER}\pysigline{\bfcode{isBFILTER}}
\end{fulllineitems}

\index{isCLAHE (RRtoolbox.lib.plotter.edger attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.edger.isCLAHE}\pysigline{\bfcode{isCLAHE}}
\end{fulllineitems}

\index{isEQUA (RRtoolbox.lib.plotter.edger attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.edger.isEQUA}\pysigline{\bfcode{isEQUA}}
\end{fulllineitems}

\index{isSIZE (RRtoolbox.lib.plotter.edger attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.edger.isSIZE}\pysigline{\bfcode{isSIZE}}
\end{fulllineitems}

\index{load() (RRtoolbox.lib.plotter.edger method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.edger.load}\pysiglinewithargsret{\bfcode{load}}{\emph{img}, \emph{compute=True}}{}
\end{fulllineitems}

\index{maxth (RRtoolbox.lib.plotter.edger attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.edger.maxth}\pysigline{\bfcode{maxth}}
\end{fulllineitems}

\index{onTrackbar1() (RRtoolbox.lib.plotter.edger method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.edger.onTrackbar1}\pysiglinewithargsret{\bfcode{onTrackbar1}}{\emph{*args}}{}
\end{fulllineitems}

\index{onTrackbar2() (RRtoolbox.lib.plotter.edger method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.edger.onTrackbar2}\pysiglinewithargsret{\bfcode{onTrackbar2}}{\emph{*args}}{}
\end{fulllineitems}

\index{save() (RRtoolbox.lib.plotter.edger method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.edger.save}\pysiglinewithargsret{\bfcode{save}}{\emph{strname=None}, \emph{ext='.png'}, \emph{name='img'}}{}
\end{fulllineitems}

\index{showgray (RRtoolbox.lib.plotter.edger attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.edger.showgray}\pysigline{\bfcode{showgray}}
\end{fulllineitems}

\index{size (RRtoolbox.lib.plotter.edger attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.edger.size}\pysigline{\bfcode{size}}
\end{fulllineitems}

\index{th1 (RRtoolbox.lib.plotter.edger attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.edger.th1}\pysigline{\bfcode{th1}}
\end{fulllineitems}

\index{th2 (RRtoolbox.lib.plotter.edger attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.edger.th2}\pysigline{\bfcode{th2}}
\end{fulllineitems}

\index{windowfunc() (RRtoolbox.lib.plotter.edger method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.edger.windowfunc}\pysiglinewithargsret{\bfcode{windowfunc}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{fastplt() (in module RRtoolbox.lib.plotter)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.fastplt}\pysiglinewithargsret{\code{RRtoolbox.lib.plotter.}\bfcode{fastplt}}{\emph{image}, \emph{cmap=None}, \emph{title='visualazor'}, \emph{win=None}, \emph{block=False}, \emph{daemon=False}}{}
Fast plot.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{image}} -- image to show

\item {} 
\textbf{\texttt{cmap}} -- ``gray'' or None

\item {} 
\textbf{\texttt{title}} -- title of subplot

\item {} 
\textbf{\texttt{win}} -- title of window

\item {} 
\textbf{\texttt{block}} -- if True it wait for window close, else it detaches (Experimental)

\item {} 
\textbf{\texttt{daemon}} -- if True window closes if main thread ends, else windows
must be closed to main thread to end (Experimental)

\end{itemize}

\item[{Returns}] \leavevmode
plt

\end{description}\end{quote}

\end{fulllineitems}

\index{graph\_filter() (in module RRtoolbox.lib.plotter)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.graph_filter}\pysiglinewithargsret{\code{RRtoolbox.lib.plotter.}\bfcode{graph\_filter}}{\emph{filters}, \emph{levels=None}, \emph{titles=None}, \emph{win=None}, \emph{single=True}, \emph{legend=True}, \emph{annotate=True}, \emph{cols=3}, \emph{scale=0.07}, \emph{show=True}, \emph{lxp=None}, \emph{lyp=None}}{}
Graph filter with standard data to watch response.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{filters}} -- list of filters

\item {} 
\textbf{\texttt{levels}} -- numpy array with values. if None tries to fit data or assumes from 0 to 255

\item {} 
\textbf{\texttt{titles}} -- list of titles for each filter in filters. if None creates the titles

\item {} 
\textbf{\texttt{win}} -- window name

\item {} 
\textbf{\texttt{single}} -- True to plot all filters in one plot. else separate each filter in a plot.

\item {} 
\textbf{\texttt{legend}} -- True to add legends.

\item {} 
\textbf{\texttt{annotate}} -- True to add annotations.

\item {} 
\textbf{\texttt{cols}} -- number of columns to create plots

\item {} 
\textbf{\texttt{scale}} -- factor from maximum to draw annotations

\item {} 
\textbf{\texttt{show}} -- to show the figure

\end{itemize}

\item[{Returns}] \leavevmode
figure

\end{description}\end{quote}

\end{fulllineitems}

\index{imtester (class in RRtoolbox.lib.plotter)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.imtester}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.plotter.}\bfcode{imtester}}{\emph{img}, \emph{win='imtester plot'}}{}
Bases: {\hyperref[RRtoolbox.lib:RRtoolbox.lib.plotter.plotim]{\emph{\code{RRtoolbox.lib.plotter.plotim}}}}

Used to test some concepts as thresholds and filters
\index{applythresh() (RRtoolbox.lib.plotter.imtester static method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.imtester.applythresh}\pysiglinewithargsret{\strong{static }\bfcode{applythresh}}{\emph{img}, \emph{type}, \emph{adaptativetoggle}, \emph{threshtoggle}, \emph{th}, \emph{blocksz}, \emph{c}, \emph{i='`}, \emph{ti='`}, \emph{info='`}, \emph{title='`}}{}
\end{fulllineitems}

\index{builtcmd() (RRtoolbox.lib.plotter.imtester method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.imtester.builtcmd}\pysiglinewithargsret{\bfcode{builtcmd}}{}{}
\end{fulllineitems}

\index{computefunc() (RRtoolbox.lib.plotter.imtester method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.imtester.computefunc}\pysiglinewithargsret{\bfcode{computefunc}}{\emph{image=None}}{}
\end{fulllineitems}

\index{detectType() (RRtoolbox.lib.plotter.imtester method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.imtester.detectType}\pysiglinewithargsret{\bfcode{detectType}}{\emph{type}, \emph{i='`}, \emph{info='`}}{}
\end{fulllineitems}

\index{formatinfo() (RRtoolbox.lib.plotter.imtester static method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.imtester.formatinfo}\pysiglinewithargsret{\strong{static }\bfcode{formatinfo}}{\emph{info}, \emph{words=9}}{}
\end{fulllineitems}

\index{updatevisualization() (RRtoolbox.lib.plotter.imtester method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.imtester.updatevisualization}\pysiglinewithargsret{\bfcode{updatevisualization}}{\emph{image}, \emph{channel}, \emph{th=None}, \emph{items=None}, \emph{thresh1=None}, \emph{thresh2=None}}{}
\end{fulllineitems}

\index{visualize() (RRtoolbox.lib.plotter.imtester method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.imtester.visualize}\pysiglinewithargsret{\bfcode{visualize}}{}{}
\end{fulllineitems}

\index{windowfunc() (RRtoolbox.lib.plotter.imtester method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.imtester.windowfunc}\pysiglinewithargsret{\bfcode{windowfunc}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{limitaxis() (in module RRtoolbox.lib.plotter)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.limitaxis}\pysiglinewithargsret{\code{RRtoolbox.lib.plotter.}\bfcode{limitaxis}}{\emph{c}, \emph{maxc}, \emph{minc=0}}{}
Limit value in axis.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{c}} -- value

\item {} 
\textbf{\texttt{maxc}} -- max c value.

\item {} 
\textbf{\texttt{minc}} -- min c value.

\end{itemize}

\item[{Returns}] \leavevmode
limited c value c E {[}minc,maxc{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{matchExplorer (class in RRtoolbox.lib.plotter)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.matchExplorer}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.plotter.}\bfcode{matchExplorer}}{\emph{win}, \emph{img1}, \emph{img2}, \emph{kp\_pairs=()}, \emph{status=None}, \emph{H=None}, \emph{show=True}, \emph{block=True}, \emph{daemon=True}}{}
Bases: {\hyperref[RRtoolbox.lib:RRtoolbox.lib.plotter.plotim]{\emph{\code{RRtoolbox.lib.plotter.plotim}}}}

Draws a set of keypoint pairs obtained on a match method of a descriptor
on two images imgf and imgb. (backend: plotim).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{win}} -- window's name (str)

\item {} 
\textbf{\texttt{img1}} -- image1 (numpy array)

\item {} 
\textbf{\texttt{img2}} -- image2 (numpy array)

\item {} 
\textbf{\texttt{kp\_pairs}} -- zip(keypoint1, keypoint2)

\item {} 
\textbf{\texttt{status}} -- obtained from cv2.findHomography

\item {} 
\textbf{\texttt{H}} -- obtained from cv2.findHomography (default=None)

\item {} 
\textbf{\texttt{show}} -- if True shows plotim using block and daemon, else do not show

\item {} 
\textbf{\texttt{block}} -- if True it wait for window close, else it detaches

\item {} 
\textbf{\texttt{daemon}} -- if True window closes if main thread ends, else windows must be closed to main thread to end

\end{itemize}

\item[{Returns}] \leavevmode
plotim object with visualization as self.rimg (image with matching result) (default=None)

\end{description}\end{quote}

\begin{notice}{note}{Note:}
It supports BGR and gray images.
\end{notice}
\index{drawline() (RRtoolbox.lib.plotter.matchExplorer method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.matchExplorer.drawline}\pysiglinewithargsret{\bfcode{drawline}}{}{}
Draws background visualization without interaction

\end{fulllineitems}

\index{drawrelation() (RRtoolbox.lib.plotter.matchExplorer method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.matchExplorer.drawrelation}\pysiglinewithargsret{\bfcode{drawrelation}}{}{}
Draw keypoints where pointer is placed and pressed

\end{fulllineitems}

\index{keyfunc() (RRtoolbox.lib.plotter.matchExplorer method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.matchExplorer.keyfunc}\pysiglinewithargsret{\bfcode{keyfunc}}{}{}
\end{fulllineitems}

\index{mousefunc() (RRtoolbox.lib.plotter.matchExplorer method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.matchExplorer.mousefunc}\pysiglinewithargsret{\bfcode{mousefunc}}{}{}
\end{fulllineitems}

\index{randomColor() (RRtoolbox.lib.plotter.matchExplorer static method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.matchExplorer.randomColor}\pysiglinewithargsret{\strong{static }\bfcode{randomColor}}{}{}
\end{fulllineitems}

\index{updaterenderer() (RRtoolbox.lib.plotter.matchExplorer method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.matchExplorer.updaterenderer}\pysiglinewithargsret{\bfcode{updaterenderer}}{\emph{img=None}, \emph{zoom=True}}{}
update renderer when called.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{img}} -- image to update in renderer, if None use self.img

\item {} 
\textbf{\texttt{zoom}} -- True to enable zoom, else updates with original img.

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{plotPointsContour() (in module RRtoolbox.lib.plotter)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.plotPointsContour}\pysiglinewithargsret{\code{RRtoolbox.lib.plotter.}\bfcode{plotPointsContour}}{\emph{pts}, \emph{ax=None}, \emph{lcor='k'}, \emph{pcor=None}, \emph{deg=None}, \emph{annotate=True}, \emph{width=0.004}, \emph{label='pt\{pt\}(\{x\}}, \emph{\{y\}}, \emph{\{a\})'}, \emph{arrowprops=None}}{}
Plots points and joining lines in axes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{pts}} -- points. {[}(x0,y0)...(xN,yN){]}

\item {} 
\textbf{\texttt{ax}} -- axes handle to draw points.

\item {} 
\textbf{\texttt{lcor}} -- color of joining lines.

\item {} 
\textbf{\texttt{pcor}} -- color of points. If specified uses lines, else vectors.

\item {} 
\textbf{\texttt{deg}} -- angle of vertex, if True in degrees, if False in radians, if None do not add.

\end{itemize}

\item[{Returns}] \leavevmode
ax.

\end{description}\end{quote}

\end{fulllineitems}

\index{plotim (class in RRtoolbox.lib.plotter)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.plotim}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.plotter.}\bfcode{plotim}}{\emph{win}, \emph{im=array({[}{[}1{]}{]})}, \emph{bgrcolor=(250}, \emph{243}, \emph{238)}}{}
Bases: \code{object}

Show and image with events, animations, controls, internal
commands and highly customizable by code.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{win}} -- window name

\item {} 
\textbf{\texttt{im}} -- image of numpy array

\item {} 
\textbf{\texttt{bgrcolor}} -- default color to use for transparent or background color.

\end{itemize}

\end{description}\end{quote}

\begin{notice}{warning}{Warning:}
plotim is deprecated and will be replaced in the future (it was made to
test concepts). Originally it was made for windows but some functions
were removed to let it be multi-platform.
\end{notice}
\index{builtincmd() (RRtoolbox.lib.plotter.plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.plotim.builtincmd}\pysiglinewithargsret{\bfcode{builtincmd}}{}{}
Internal cmd control

\end{fulllineitems}

\index{builtincontrol() (RRtoolbox.lib.plotter.plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.plotim.builtincontrol}\pysiglinewithargsret{\bfcode{builtincontrol}}{\emph{control=False}}{}
Internal control. use self.usecontrol = True to activate.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{control}} -- if True, use control key.

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{builtinplot() (RRtoolbox.lib.plotter.plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.plotim.builtinplot}\pysiglinewithargsret{\bfcode{builtinplot}}{\emph{pixel=None}, \emph{useritems=None}, \emph{flag=1}, \emph{xpad=0}, \emph{ypad=0}, \emph{bgrcolor=None}, \emph{alpha=None}}{}
Internal plot.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{pixel}} -- pixel color where mouse is placed (placed for better control). Color can be from
real image, showed image, original image or rendered image, or any color.

\item {} 
\textbf{\texttt{useritems}} -- items to show.

\item {} 
\textbf{\texttt{flag}} -- 
flag for position (default=0).
\begin{itemize}
\item {} 
flag==0 : foreground to left up.

\item {} 
flag==1 : foreground to left down.

\item {} 
flag==2 : foreground to right up.

\item {} 
flag==3 : foreground to right down.

\item {} 
flag==4 : foreground at center of background.

\item {} 
flag==5 : XY 0,0 is at center of background.

\item {} 
flag==6 : XY 0,0 is at center of foreground.

\item {} 
flag==7 : XY 0,0 is at right down of foreground.

\end{itemize}


\item {} 
\textbf{\texttt{xpad}} -- padding in x

\item {} 
\textbf{\texttt{ypad}} -- padding in y

\item {} 
\textbf{\texttt{bgrcolor}} -- background color

\item {} 
\textbf{\texttt{alpha}} -- alpha mask or value for transparency

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{builtinwindow() (RRtoolbox.lib.plotter.plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.plotim.builtinwindow}\pysiglinewithargsret{\bfcode{builtinwindow}}{}{}
loads windowfunc, showfunc, starts window thread and mousecallback.

\end{fulllineitems}

\index{clean() (RRtoolbox.lib.plotter.plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.plotim.clean}\pysiglinewithargsret{\bfcode{clean}}{}{}
Attempt to clean the plotter dictionary for an error in
garbage collection.
:return:

\end{fulllineitems}

\index{closefunc() (RRtoolbox.lib.plotter.plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.plotim.closefunc}\pysiglinewithargsret{\bfcode{closefunc}}{}{}
Decoupled close function for plotim (replace self.closefunc).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- plotim instance

\end{description}\end{quote}

\end{fulllineitems}

\index{cmdfunc() (RRtoolbox.lib.plotter.plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.plotim.cmdfunc}\pysiglinewithargsret{\bfcode{cmdfunc}}{\emph{execute=False}}{}
command function and decoupled cmd solver for plotim. (repalce self.cmdfunc)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{self}} -- 

\item {} 
\textbf{\texttt{execute}} -- True, enable execution of commands, False, disable execution.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{errorbackground (RRtoolbox.lib.plotter.plotim attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.plotim.errorbackground}\pysigline{\bfcode{errorbackground}}
\end{fulllineitems}

\index{formatcmd() (RRtoolbox.lib.plotter.plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.plotim.formatcmd}\pysiglinewithargsret{\bfcode{formatcmd}}{\emph{cmd}, \emph{references=(`+'}, \emph{`-`}, \emph{`*'}, \emph{`=')}, \emph{lmissing='self.'}}{}
Decoupled cmd formatter for cmdfunc and plotim.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{self}} -- plotim instance

\item {} 
\textbf{\texttt{cmd}} -- command

\item {} 
\textbf{\texttt{references}} -- 

\item {} 
\textbf{\texttt{lmissing}} -- assumed missing part in command

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{help() (RRtoolbox.lib.plotter.plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.plotim.help}\pysiglinewithargsret{\bfcode{help}}{\emph{showAll=False}}{}
function to print the quick help for the user with all the commands

\end{fulllineitems}

\index{init() (RRtoolbox.lib.plotter.plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.plotim.init}\pysiglinewithargsret{\bfcode{init}}{}{}
Pseudo \_\_init\_\_. it is used to restart default
values without destroying configurations.

\end{fulllineitems}

\index{keyfunc() (RRtoolbox.lib.plotter.plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.plotim.keyfunc}\pysiglinewithargsret{\bfcode{keyfunc}}{}{}
Decoupled key function for plotim (replace self.keyfunc).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- plotim instance

\end{description}\end{quote}

\end{fulllineitems}

\index{makeoverlay() (RRtoolbox.lib.plotter.plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.plotim.makeoverlay}\pysiglinewithargsret{\bfcode{makeoverlay}}{\emph{items}, \emph{xpad=0}, \emph{ypad=0}, \emph{bgrcolor=None}, \emph{alpha=None}}{}
overlay items over image.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{self}} -- instance

\item {} 
\textbf{\texttt{items}} -- list of object to overlay

\item {} 
\textbf{\texttt{xpad}} -- pad in x

\item {} 
\textbf{\texttt{ypad}} -- pad in y

\item {} 
\textbf{\texttt{bgrcolor}} -- background color

\item {} 
\textbf{\texttt{alpha}} -- transparency color

\end{itemize}

\item[{Returns}] \leavevmode
overlayed

\end{description}\end{quote}

\end{fulllineitems}

\index{mousefunc() (RRtoolbox.lib.plotter.plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.plotim.mousefunc}\pysiglinewithargsret{\bfcode{mousefunc}}{}{}
Decoupled mouse function for plotim (replace self.mousefunc).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- plotim instance

\end{description}\end{quote}

\end{fulllineitems}

\index{onmouse() (RRtoolbox.lib.plotter.plotim static method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.plotim.onmouse}\pysiglinewithargsret{\strong{static }\bfcode{onmouse}}{\emph{event}, \emph{x}, \emph{y}, \emph{flags}, \emph{self}}{}
Mouse event function for plotim. (replace self.mousefunc)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{event}} -- mouse event

\item {} 
\textbf{\texttt{x}} -- x position

\item {} 
\textbf{\texttt{y}} -- y postion

\item {} 
\textbf{\texttt{flags}} -- mouse flag to use in control (it represents clicks)

\item {} 
\textbf{\texttt{self}} -- plotim object

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{plotatpointer() (RRtoolbox.lib.plotter.plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.plotim.plotatpointer}\pysiglinewithargsret{\bfcode{plotatpointer}}{\emph{items}, \emph{img=None}, \emph{x=0}, \emph{y=0}, \emph{flag=6}, \emph{xpad=0}, \emph{ypad=0}, \emph{bgrcolor=None}, \emph{alpha=None}, \emph{pixel=None}}{}
Plot message where mouse pointer is.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{items}} -- list of items supported by \code{self.makeoverlay()}

\item {} 
\textbf{\texttt{img}} -- image to place in items. If None it uses self.remg

\item {} 
\textbf{\texttt{x}} -- x position

\item {} 
\textbf{\texttt{y}} -- y position

\item {} 
\textbf{\texttt{flag}} -- 
flag for position (default=0).
\begin{itemize}
\item {} 
flag==0 : foreground to left up.

\item {} 
flag==1 : foreground to left down.

\item {} 
flag==2 : foreground to right up.

\item {} 
flag==3 : foreground to right down.

\item {} 
flag==4 : foreground at center of background.

\item {} 
flag==5 : XY 0,0 is at center of background.

\item {} 
flag==6 : XY 0,0 is at center of foreground.

\item {} 
flag==7 : XY 0,0 is at right down of foreground.

\end{itemize}


\item {} 
\textbf{\texttt{xpad}} -- padding in x

\item {} 
\textbf{\texttt{ypad}} -- padding in y

\item {} 
\textbf{\texttt{bgrcolor}} -- background color

\item {} 
\textbf{\texttt{alpha}} -- alpha mask or value for transparency

\item {} 
\textbf{\texttt{pixel}} -- color to add as item im items,

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{plotatxy() (RRtoolbox.lib.plotter.plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.plotim.plotatxy}\pysiglinewithargsret{\bfcode{plotatxy}}{\emph{items}, \emph{img=None}, \emph{x=0}, \emph{y=0}, \emph{flag=0}, \emph{xpad=0}, \emph{ypad=0}, \emph{bgrcolor=None}, \emph{alpha=None}}{}
Plot message in xy position.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{items}} -- list of items supported by {\hyperref[RRtoolbox.lib:RRtoolbox.lib.plotter.plotim.makeoverlay]{\emph{\code{makeoverlay()}}}}

\item {} 
\textbf{\texttt{img}} -- image to place in items. If None it uses self.remg

\item {} 
\textbf{\texttt{x}} -- x position

\item {} 
\textbf{\texttt{y}} -- y position

\item {} 
\textbf{\texttt{flag}} -- 
flag for position (default=0).
\begin{itemize}
\item {} 
flag==0 : foreground to left up.

\item {} 
flag==1 : foreground to left down.

\item {} 
flag==2 : foreground to right up.

\item {} 
flag==3 : foreground to right down.

\item {} 
flag==4 : foreground at center of background.

\item {} 
flag==5 : XY 0,0 is at center of background.

\item {} 
flag==6 : XY 0,0 is at center of foreground.

\item {} 
flag==7 : XY 0,0 is at right down of foreground.

\end{itemize}


\item {} 
\textbf{\texttt{xpad}} -- padding in x

\item {} 
\textbf{\texttt{ypad}} -- padding in y

\item {} 
\textbf{\texttt{bgrcolor}} -- background color

\item {} 
\textbf{\texttt{alpha}} -- alpha mask or value for transparency

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{plotintime() (RRtoolbox.lib.plotter.plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.plotim.plotintime}\pysiglinewithargsret{\bfcode{plotintime}}{\emph{items=None}, \emph{wait=2}, \emph{img=None}, \emph{bgrcolor=None}}{}
plots messages and events.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{items}} -- list of items supported by {\hyperref[RRtoolbox.lib:RRtoolbox.lib.plotter.plotim.makeoverlay]{\emph{\code{makeoverlay()}}}}

\item {} 
\textbf{\texttt{wait}} -- time of message.

\item {} 
\textbf{\texttt{img}} -- image to place in items. If None it uses self.remg

\item {} 
\textbf{\texttt{bgrcolor}} -- color of message.

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{real2render() (RRtoolbox.lib.plotter.plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.plotim.real2render}\pysiglinewithargsret{\bfcode{real2render}}{\emph{x}, \emph{y}, \emph{astype=None}}{}
from real coordinates get rendered coordinates.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{x}} -- real x

\item {} 
\textbf{\texttt{y}} -- real y

\item {} 
\textbf{\texttt{astype}} -- (np.int32) return as the specified type

\end{itemize}

\item[{Returns}] \leavevmode
rendered x, rendered y

\end{description}\end{quote}

\end{fulllineitems}

\index{render2real() (RRtoolbox.lib.plotter.plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.plotim.render2real}\pysiglinewithargsret{\bfcode{render2real}}{\emph{rx}, \emph{ry}, \emph{astype=\textless{}type `numpy.int32'\textgreater{}}}{}
from rendered coordinates get real coordinates.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{rx}} -- rendered x

\item {} 
\textbf{\texttt{ry}} -- rendered y

\item {} 
\textbf{\texttt{astype}} -- (np.int32) return as the specified type

\end{itemize}

\item[{Returns}] \leavevmode
real x, real y

\end{description}\end{quote}

\end{fulllineitems}

\index{rx1 (RRtoolbox.lib.plotter.plotim attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.plotim.rx1}\pysigline{\bfcode{rx1}}
\end{fulllineitems}

\index{rx2 (RRtoolbox.lib.plotter.plotim attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.plotim.rx2}\pysigline{\bfcode{rx2}}
\end{fulllineitems}

\index{ry1 (RRtoolbox.lib.plotter.plotim attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.plotim.ry1}\pysigline{\bfcode{ry1}}
\end{fulllineitems}

\index{ry2 (RRtoolbox.lib.plotter.plotim attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.plotim.ry2}\pysigline{\bfcode{ry2}}
\end{fulllineitems}

\index{save() (RRtoolbox.lib.plotter.plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.plotim.save}\pysiglinewithargsret{\bfcode{save}}{\emph{strname=None}, \emph{ext='.png'}, \emph{name='img'}}{}
Save image (save image if not Qt backend is installed)
:param strname: name to save, a label with \{win\} can be used to be replaced with the plot win name
:param ext: (''.png'') extension.
:param name: (``img'') name of image object from self. default is ``img'' that is self.img
\begin{quote}

(it allows better control to get custom image)
\end{quote}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
True if saved, False if not saved (possibly because folder does not exists)

\end{description}\end{quote}

\end{fulllineitems}

\index{show() (RRtoolbox.lib.plotter.plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.plotim.show}\pysiglinewithargsret{\bfcode{show}}{\emph{frames=None}, \emph{block=True}, \emph{daemon=False}, \emph{clean=True}}{}
Show function. calls buildinwindow, handles key presses and close events.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{frames}} -- show number of frames and close.

\item {} 
\textbf{\texttt{block}} -- if True it wait for window close, else it detaches (Experimental)

\item {} 
\textbf{\texttt{daemon}} -- if True window closes if main thread ends,
else windows must be closed to main thread to end (Experimental)

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{showfunc() (RRtoolbox.lib.plotter.plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.plotim.showfunc}\pysiglinewithargsret{\bfcode{showfunc}}{\emph{img=None}}{}
Decoupled show function for plotim (replace self.showfunc).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{self}} -- plotim instance

\item {} 
\textbf{\texttt{img}} -- image to show

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{textbackground (RRtoolbox.lib.plotter.plotim attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.plotim.textbackground}\pysigline{\bfcode{textbackground}}
\end{fulllineitems}

\index{updaterenderer() (RRtoolbox.lib.plotter.plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.plotim.updaterenderer}\pysiglinewithargsret{\bfcode{updaterenderer}}{\emph{img=None}, \emph{zoom=True}}{}
update renderer when called.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{img}} -- image to update in renderer, if None use self.img

\item {} 
\textbf{\texttt{zoom}} -- True to enable zoom, else updates with original img.

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{windowfunc() (RRtoolbox.lib.plotter.plotim method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.plotter.plotim.windowfunc}\pysiglinewithargsret{\bfcode{windowfunc}}{}{}
Decoupled window function for plotim (replace self.windowfunc).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- plotim instance

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{RRtoolbox.lib.root module}
\label{RRtoolbox.lib:rrtoolbox-lib-root-module}\label{RRtoolbox.lib:module-RRtoolbox.lib.root}\index{RRtoolbox.lib.root (module)}
This module holds core-like methods for library modules but not for the hole package
\index{Controlstdout() (in module RRtoolbox.lib.root)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.Controlstdout}\pysiglinewithargsret{\code{RRtoolbox.lib.root.}\bfcode{Controlstdout}}{\emph{*args}, \emph{**kwds}}{}
Context manager to control output to stdout
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{disable}} -- if True suppress output.

\end{description}\end{quote}

\end{fulllineitems}

\index{FactorConvert (class in RRtoolbox.lib.root)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.FactorConvert}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.root.}\bfcode{FactorConvert}}{\emph{factor=None}, \emph{factorIndex=1}}{}
Bases: \code{object}

Keep track of factor and converts to any available factor.
\index{convert() (RRtoolbox.lib.root.FactorConvert method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.FactorConvert.convert}\pysiglinewithargsret{\bfcode{convert}}{\emph{factor}, \emph{to=None}}{}
Convert from actual factor to another factor.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{factor}} -- number

\item {} 
\textbf{\texttt{to}} -- factor to convert

\end{itemize}

\item[{Returns}] \leavevmode
converted value, units

\end{description}\end{quote}

\end{fulllineitems}

\index{convert2sample() (RRtoolbox.lib.root.FactorConvert method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.FactorConvert.convert2sample}\pysiglinewithargsret{\bfcode{convert2sample}}{\emph{factor}, \emph{to=None}}{}
Convert to resemble sample.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{factor}} -- number

\item {} 
\textbf{\texttt{to}} -- sample factor.

\end{itemize}

\item[{Returns}] \leavevmode
converted value, units

\end{description}\end{quote}

\end{fulllineitems}

\index{exactFactorIndex() (RRtoolbox.lib.root.FactorConvert method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.FactorConvert.exactFactorIndex}\pysiglinewithargsret{\bfcode{exactFactorIndex}}{\emph{key}}{}
Find the index of a factor that contains a key.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{key}} -- anything to look in factors (i.e. factor name, factor value, abbreviation).

\item[{Returns}] \leavevmode
factor structure, else None.

\end{description}\end{quote}

\end{fulllineitems}

\index{factor (RRtoolbox.lib.root.FactorConvert attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.FactorConvert.factor}\pysigline{\bfcode{factor}}
\end{fulllineitems}

\index{factors (RRtoolbox.lib.root.FactorConvert attribute)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.FactorConvert.factors}\pysigline{\bfcode{factors}}
\end{fulllineitems}

\index{getFactor() (RRtoolbox.lib.root.FactorConvert method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.FactorConvert.getFactor}\pysiglinewithargsret{\bfcode{getFactor}}{\emph{key}}{}
Tries to find factor value in factors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{key}} -- anything to look in factors (i.e. factor name, factor value, abbreviation).
If key is a factor value it will look for the nearest factor value.

\item[{Returns}] \leavevmode
factor structure, else raises error.

\end{description}\end{quote}

\end{fulllineitems}

\index{nearFactorIndex() (RRtoolbox.lib.root.FactorConvert method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.FactorConvert.nearFactorIndex}\pysiglinewithargsret{\bfcode{nearFactorIndex}}{\emph{factor}}{}
Find the index of nearest factor value.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{factor}} -- factor value.

\item[{Returns}] \leavevmode
factor structure near factor value.

\end{description}\end{quote}

\end{fulllineitems}

\index{parts() (RRtoolbox.lib.root.FactorConvert static method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.FactorConvert.parts}\pysiglinewithargsret{\strong{static }\bfcode{parts}}{\emph{value}, \emph{precision=4}}{}
Get number parts.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{value}} -- number

\item {} 
\textbf{\texttt{precision}} -- decimal precision

\end{itemize}

\item[{Returns}] \leavevmode
({[}... ,Hundreds, Tens, Ones{]},{[}Tenths, ...{]})

\end{description}\end{quote}

\end{fulllineitems}

\index{split() (RRtoolbox.lib.root.FactorConvert static method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.FactorConvert.split}\pysiglinewithargsret{\strong{static }\bfcode{split}}{\emph{value}}{}
Get number fraction.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{value}} -- number

\item[{Returns}] \leavevmode
integer, fraction

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{TimeCode() (in module RRtoolbox.lib.root)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.TimeCode}\pysiglinewithargsret{\code{RRtoolbox.lib.root.}\bfcode{TimeCode}}{\emph{*args}, \emph{**kwds}}{}
Context to profile code by printing a prelude and prologue with time.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{msg}} -- prelude or description message

\item {} 
\textbf{\texttt{unit}} -- unit supported by FactorConvert class

\item {} 
\textbf{\texttt{precision}} -- number of digits after a float point

\item {} 
\textbf{\texttt{abv}} -- if True prints ``s'', if False ``seconds'' for time

\item {} 
\textbf{\texttt{endmsg}} -- prologue message

\item {} 
\textbf{\texttt{enableMsg}} -- (True) A flag specifying if context
should be printed or not.

\item {} 
\textbf{\texttt{printfunc}} -- function to print messages. By default it
is sys.stdout.write

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{addto() (in module RRtoolbox.lib.root)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.addto}\pysiglinewithargsret{\code{RRtoolbox.lib.root.}\bfcode{addto}}{\emph{instance}, \emph{funcname=None}}{}
Decorator: Add function as method to instance.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{instance}} -- class instance.

\item {} 
\textbf{\texttt{funcname}} -- name to register in instance.

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{decorateInstanceMethods() (in module RRtoolbox.lib.root)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.decorateInstanceMethods}\pysiglinewithargsret{\code{RRtoolbox.lib.root.}\bfcode{decorateInstanceMethods}}{\emph{self}, \emph{decorator}, \emph{excludeMth='\_\_init\_\_'}, \emph{includeMth=None}}{}
Decorate methods in an instance. It should be used in the \_\_init\_\_ method of a class.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{self}} -- class instance.

\item {} 
\textbf{\texttt{decorator}} -- decorator function to apply to self.

\item {} 
\textbf{\texttt{excludeMth}} -- list of methods to exclude.

\item {} 
\textbf{\texttt{includeMth}} -- list of methods to include if not in exclude.
if excludeMth is None then decorateInstanceMethods checks for includeMth list.
if includeMth and excludeMth is None then all methods of self are decorated.

\end{itemize}

\item[{Returns}] \leavevmode
self

\end{description}\end{quote}

\begin{notice}{note}{Note:}
It must be used at instance initialization (i.e. inside \_\_init\_\_ method)
\end{notice}

\end{fulllineitems}

\index{glob() (in module RRtoolbox.lib.root)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.glob}\pysiglinewithargsret{\code{RRtoolbox.lib.root.}\bfcode{glob}}{\emph{path}}{}
Return a list of paths matching a pathname pattern with valid files.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{path}} -- path to process ing glob filter

\item[{Returns}] \leavevmode
return list of files

\end{description}\end{quote}

\end{fulllineitems}

\index{lookinglob() (in module RRtoolbox.lib.root)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.lookinglob}\pysiglinewithargsret{\code{RRtoolbox.lib.root.}\bfcode{lookinglob}}{\emph{pattern}, \emph{path}, \emph{ext=None}, \emph{returnAll=False}, \emph{raiseErr=False}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{pattern}} -- look pattern in path

\item {} 
\textbf{\texttt{path}} -- path to look pattern

\item {} 
\textbf{\texttt{ext}} -- extension

\item {} 
\textbf{\texttt{raiseErr}} -- If true raise Exception if patter not found in path

\end{itemize}

\item[{Returns}] \leavevmode
fn or None

\end{description}\end{quote}

\end{fulllineitems}

\index{stdoutLOG (class in RRtoolbox.lib.root)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.stdoutLOG}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.root.}\bfcode{stdoutLOG}}{\emph{path}, \emph{mode='w+'}, \emph{chain=False}}{}
simple logger to save stdout output
so anything printed in the console is logged to a file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{path}} -- path to logging file

\item {} 
\textbf{\texttt{mode}} -- mode for opening the file.

\item {} 
\textbf{\texttt{chain}} -- if True closes previous logs and continues with new log

\end{itemize}

\end{description}\end{quote}
\index{close() (RRtoolbox.lib.root.stdoutLOG method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.stdoutLOG.close}\pysiglinewithargsret{\bfcode{close}}{}{}
\end{fulllineitems}

\index{flush() (RRtoolbox.lib.root.stdoutLOG method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.stdoutLOG.flush}\pysiglinewithargsret{\bfcode{flush}}{}{}
\end{fulllineitems}

\index{printline() (RRtoolbox.lib.root.stdoutLOG method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.stdoutLOG.printline}\pysiglinewithargsret{\bfcode{printline}}{\emph{text}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{printlines() (RRtoolbox.lib.root.stdoutLOG method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.stdoutLOG.printlines}\pysiglinewithargsret{\bfcode{printlines}}{\emph{lines}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{write() (RRtoolbox.lib.root.stdoutLOG method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.stdoutLOG.write}\pysiglinewithargsret{\bfcode{write}}{\emph{text}, \emph{**kwargs}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{stdoutSIM (class in RRtoolbox.lib.root)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.stdoutSIM}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.root.}\bfcode{stdoutSIM}}{\emph{disable=False}}{}
simple logger to simulate stdout output
\index{close() (RRtoolbox.lib.root.stdoutSIM method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.stdoutSIM.close}\pysiglinewithargsret{\bfcode{close}}{}{}
\end{fulllineitems}

\index{flush() (RRtoolbox.lib.root.stdoutSIM method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.stdoutSIM.flush}\pysiglinewithargsret{\bfcode{flush}}{}{}
\end{fulllineitems}

\index{printline() (RRtoolbox.lib.root.stdoutSIM method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.stdoutSIM.printline}\pysiglinewithargsret{\bfcode{printline}}{\emph{text}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{printlines() (RRtoolbox.lib.root.stdoutSIM method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.stdoutSIM.printlines}\pysiglinewithargsret{\bfcode{printlines}}{\emph{lines}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{write() (RRtoolbox.lib.root.stdoutSIM method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.root.stdoutSIM.write}\pysiglinewithargsret{\bfcode{write}}{\emph{text}, \emph{**kwargs}}{}
\end{fulllineitems}


\end{fulllineitems}



\subsubsection{RRtoolbox.lib.serverServices module}
\label{RRtoolbox.lib:rrtoolbox-lib-serverservices-module}\label{RRtoolbox.lib:module-RRtoolbox.lib.serverServices}\index{RRtoolbox.lib.serverServices (module)}\index{Conection (class in RRtoolbox.lib.serverServices)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.serverServices.Conection}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.lib.serverServices.}\bfcode{Conection}}{\emph{conn}}{}
represent a connection to interchange objects between servers and clients.
\index{getLen() (RRtoolbox.lib.serverServices.Conection method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.serverServices.Conection.getLen}\pysiglinewithargsret{\bfcode{getLen}}{\emph{timeout=None}}{}
\end{fulllineitems}

\index{rcv() (RRtoolbox.lib.serverServices.Conection method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.serverServices.Conection.rcv}\pysiglinewithargsret{\bfcode{rcv}}{}{}
\end{fulllineitems}

\index{recvall() (RRtoolbox.lib.serverServices.Conection method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.serverServices.Conection.recvall}\pysiglinewithargsret{\bfcode{recvall}}{}{}
\end{fulllineitems}

\index{send() (RRtoolbox.lib.serverServices.Conection method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.serverServices.Conection.send}\pysiglinewithargsret{\bfcode{send}}{\emph{obj}}{}
\end{fulllineitems}

\index{sendLen() (RRtoolbox.lib.serverServices.Conection method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.serverServices.Conection.sendLen}\pysiglinewithargsret{\bfcode{sendLen}}{\emph{length}, \emph{timeout=None}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{TimeOutException}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.serverServices.TimeOutException}\pysigline{\strong{exception }\code{RRtoolbox.lib.serverServices.}\bfcode{TimeOutException}}
Bases: \code{exceptions.Exception}

\end{fulllineitems}

\index{TransferExeption}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.serverServices.TransferExeption}\pysigline{\strong{exception }\code{RRtoolbox.lib.serverServices.}\bfcode{TransferExeption}}
Bases: \code{exceptions.Exception}

\end{fulllineitems}

\index{generateServer() (in module RRtoolbox.lib.serverServices)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.serverServices.generateServer}\pysiglinewithargsret{\code{RRtoolbox.lib.serverServices.}\bfcode{generateServer}}{\emph{host='localhost'}, \emph{to=63342}}{}
generates a simple Server in available address.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{to}} -- until port.

\item[{Returns}] \leavevmode
socket, address

\end{description}\end{quote}

\end{fulllineitems}

\index{initClient() (in module RRtoolbox.lib.serverServices)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.serverServices.initClient}\pysiglinewithargsret{\code{RRtoolbox.lib.serverServices.}\bfcode{initClient}}{\emph{addr}, \emph{timeout=None}}{}
Inits a simple client from address.
:param addr: (host, port)
:return: socket

\end{fulllineitems}

\index{initServer() (in module RRtoolbox.lib.serverServices)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.serverServices.initServer}\pysiglinewithargsret{\code{RRtoolbox.lib.serverServices.}\bfcode{initServer}}{\emph{addr}}{}
Inits a simple server from address.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{addr}} -- (host, port)

\item[{Returns}] \leavevmode
socket

\end{description}\end{quote}

\end{fulllineitems}

\index{parseString() (in module RRtoolbox.lib.serverServices)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.serverServices.parseString}\pysiglinewithargsret{\code{RRtoolbox.lib.serverServices.}\bfcode{parseString}}{\emph{string}, \emph{timeout=3}}{}
\end{fulllineitems}

\index{ping() (in module RRtoolbox.lib.serverServices)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.serverServices.ping}\pysiglinewithargsret{\code{RRtoolbox.lib.serverServices.}\bfcode{ping}}{\emph{host}, \emph{port}}{}
Ping to.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{host}} -- IP address

\item {} 
\textbf{\texttt{port}} -- port address

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{rcvPickle() (in module RRtoolbox.lib.serverServices)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.serverServices.rcvPickle}\pysiglinewithargsret{\code{RRtoolbox.lib.serverServices.}\bfcode{rcvPickle}}{\emph{addr=(`localhost'}, \emph{50007)}, \emph{timeout=None}}{}
Receive potentially any data using sockets.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{addr}} -- socket or address.

\item {} 
\textbf{\texttt{timeout}} -- NotImplemented

\end{itemize}

\item[{Returns}] \leavevmode
data, else throws error.

\end{description}\end{quote}

\end{fulllineitems}

\index{recv\_into() (in module RRtoolbox.lib.serverServices)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.serverServices.recv_into}\pysiglinewithargsret{\code{RRtoolbox.lib.serverServices.}\bfcode{recv\_into}}{\emph{viewable}, \emph{socket}}{}
Receive from socket into viewable object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{viewable}} -- viewable object

\item {} 
\textbf{\texttt{socket}} -- source socket

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{scan\_ports() (in module RRtoolbox.lib.serverServices)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.serverServices.scan_ports}\pysiglinewithargsret{\code{RRtoolbox.lib.serverServices.}\bfcode{scan\_ports}}{\emph{host}}{}
Scan opened ports in address.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{host}} -- host IP to filter opened ports.

\item[{Returns}] \leavevmode
generator

\end{description}\end{quote}

\end{fulllineitems}

\index{sendPickle() (in module RRtoolbox.lib.serverServices)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.serverServices.sendPickle}\pysiglinewithargsret{\code{RRtoolbox.lib.serverServices.}\bfcode{sendPickle}}{\emph{obj}, \emph{addr=(`localhost'}, \emph{50007)}, \emph{timeout=None}, \emph{threaded=False}}{}
Send potentially any data using sockets.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{obj}} -- packable object.

\item {} 
\textbf{\texttt{addr}} -- socket or address.

\item {} 
\textbf{\texttt{timeout}} -- NotImplemented

\end{itemize}

\item[{Returns}] \leavevmode
True if sent successfully, else Throw error.

\end{description}\end{quote}

\end{fulllineitems}

\index{send\_from() (in module RRtoolbox.lib.serverServices)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.serverServices.send_from}\pysiglinewithargsret{\code{RRtoolbox.lib.serverServices.}\bfcode{send\_from}}{\emph{viewable}, \emph{socket}}{}
Send from viewable object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{viewable}} -- viewable object

\item {} 
\textbf{\texttt{socket}} -- destine socket

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{RRtoolbox.lib.session module}
\label{RRtoolbox.lib:module-RRtoolbox.lib.session}\label{RRtoolbox.lib:rrtoolbox-lib-session-module}\index{RRtoolbox.lib.session (module)}
This module have serializing methods for data persistence so to let the package ``save'' custom objects

session module made by Davtoh and powered by dill
Dependency project: \href{https://github.com/uqfoundation/dill}{https://github.com/uqfoundation/dill}
\index{checkFromSession() (in module RRtoolbox.lib.session)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.session.checkFromSession}\pysiglinewithargsret{\code{RRtoolbox.lib.session.}\bfcode{checkFromSession}}{\emph{filepath}, \emph{varlist}}{}
Check that variables exits in session file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{filepath}} -- path to session file.

\item {} 
\textbf{\texttt{varlist}} -- list of variables to checkLoaded.

\end{itemize}

\item[{Returns}] \leavevmode
list checkLoaded results

\end{description}\end{quote}

\end{fulllineitems}

\index{deleteFromSession() (in module RRtoolbox.lib.session)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.session.deleteFromSession}\pysiglinewithargsret{\code{RRtoolbox.lib.session.}\bfcode{deleteFromSession}}{\emph{filepath}, \emph{varlist}}{}
Delete variables from session file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{filepath}} -- path to session file.

\item {} 
\textbf{\texttt{varlist}} -- list of variables to delete.

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{flushSession() (in module RRtoolbox.lib.session)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.session.flushSession}\pysiglinewithargsret{\code{RRtoolbox.lib.session.}\bfcode{flushSession}}{\emph{filepath}}{}
Empty session in file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{filepath}} -- path to session file.

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{getEnviromentSession() (in module RRtoolbox.lib.session)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.session.getEnviromentSession}\pysiglinewithargsret{\code{RRtoolbox.lib.session.}\bfcode{getEnviromentSession}}{\emph{enviroment=None}}{}
Gets the filtered session from the global variables.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
dictionary containing filtered session.

\end{description}\end{quote}

\end{fulllineitems}

\index{readSession() (in module RRtoolbox.lib.session)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.session.readSession}\pysiglinewithargsret{\code{RRtoolbox.lib.session.}\bfcode{readSession}}{\emph{filepath}, \emph{helper=None}}{}
Loads a dictionary session from file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{filepath}} -- path to load session file.

\item {} 
\textbf{\texttt{helper}} -- function to pos-process session file

\end{itemize}

\item[{Returns}] \leavevmode
session

\end{description}\end{quote}

\end{fulllineitems}

\index{saveSession() (in module RRtoolbox.lib.session)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.session.saveSession}\pysiglinewithargsret{\code{RRtoolbox.lib.session.}\bfcode{saveSession}}{\emph{filepath}, \emph{session}, \emph{helper=None}}{}
Saves dictionary session to file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{filepath}} -- path to save session file.

\item {} 
\textbf{\texttt{session}} -- dictionary

\item {} 
\textbf{\texttt{helper}} -- function to pre-process session

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{updateSession() (in module RRtoolbox.lib.session)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.lib:RRtoolbox.lib.session.updateSession}\pysiglinewithargsret{\code{RRtoolbox.lib.session.}\bfcode{updateSession}}{\emph{filepath}, \emph{session}, \emph{replace=True}, \emph{rdhelper=None}, \emph{svhelper=None}}{}
Updates a dictionary session in file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{filepath}} -- path to session file.

\item {} 
\textbf{\texttt{session}} -- dictionary.

\item {} 
\textbf{\texttt{replace}} -- if True key values are replaced else old key values ar kept.

\item {} 
\textbf{\texttt{rdhelper}} -- read helper.

\item {} 
\textbf{\texttt{svhelper}} -- save helper.

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{Module contents}
\label{RRtoolbox.lib:module-RRtoolbox.lib}\label{RRtoolbox.lib:module-contents}\index{RRtoolbox.lib (module)}
This module contains core-like, too-much-used and too-much-referenced modules


\subsection{RRtoolbox.tools package}
\label{RRtoolbox.tools::doc}\label{RRtoolbox.tools:rrtoolbox-tools-package}

\subsubsection{Submodules}
\label{RRtoolbox.tools:submodules}

\subsubsection{RRtoolbox.tools.lens module}
\label{RRtoolbox.tools:rrtoolbox-tools-lens-module}\label{RRtoolbox.tools:module-RRtoolbox.tools.lens}\index{RRtoolbox.tools.lens (module)}\index{drawCircle() (in module RRtoolbox.tools.lens)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.lens.drawCircle}\pysiglinewithargsret{\code{RRtoolbox.tools.lens.}\bfcode{drawCircle}}{\emph{array}, \emph{cnt}, \emph{color=0}}{}
project circle over array.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{array}} -- array to draw circle

\item {} 
\textbf{\texttt{cnt}} -- contours of segmentation to fit circle

\item {} 
\textbf{\texttt{color}} -- color of lens

\end{itemize}

\item[{Returns}] \leavevmode
array

\end{description}\end{quote}

\end{fulllineitems}

\index{drawEllipse() (in module RRtoolbox.tools.lens)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.lens.drawEllipse}\pysiglinewithargsret{\code{RRtoolbox.tools.lens.}\bfcode{drawEllipse}}{\emph{array}, \emph{cnt}, \emph{color=0}}{}
project ellipse over array.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{array}} -- array to draw ellipse

\item {} 
\textbf{\texttt{cnt}} -- contours of segmentation to fit ellipse

\item {} 
\textbf{\texttt{color}} -- color of lens

\end{itemize}

\item[{Returns}] \leavevmode
array

\end{description}\end{quote}

\end{fulllineitems}

\index{fitLens() (in module RRtoolbox.tools.lens)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.lens.fitLens}\pysiglinewithargsret{\code{RRtoolbox.tools.lens.}\bfcode{fitLens}}{\emph{img}, \emph{mask}, \emph{color=0}, \emph{asEllipse=False}, \emph{addmask=False}}{}
Place lens-like object in image.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{img}} -- image to place lens

\item {} 
\textbf{\texttt{mask}} -- mask to fit lens

\item {} 
\textbf{\texttt{color}} -- color of the lens

\item {} 
\textbf{\texttt{asEllipse}} -- True to fit lens as a ellipse, False to fit circle.

\item {} 
\textbf{\texttt{addmask}} -- return additional mask parameter

\end{itemize}

\item[{Returns}] \leavevmode
image with simulated lens

\end{description}\end{quote}

\end{fulllineitems}

\index{simulateLens() (in module RRtoolbox.tools.lens)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.lens.simulateLens}\pysiglinewithargsret{\code{RRtoolbox.tools.lens.}\bfcode{simulateLens}}{\emph{img}, \emph{threshfunc=None}, \emph{pshape=(300}, \emph{300)}, \emph{color=0}, \emph{asEllipse=True}}{}
Place lens-like object in image.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{img}} -- image to place lens.

\item {} 
\textbf{\texttt{threshfunc}} -- function to segment retinal area and get its mask.

\item {} 
\textbf{\texttt{pshape}} -- shape to resize processing image to increase performance.

\item {} 
\textbf{\texttt{color}} -- color of the lens.

\item {} 
\textbf{\texttt{asEllipse}} -- True to fit lens as a ellipse, False to fit circle.

\end{itemize}

\item[{Returns}] \leavevmode
image with simulated lens.

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{RRtoolbox.tools.restoration module}
\label{RRtoolbox.tools:rrtoolbox-tools-restoration-module}

\subsubsection{RRtoolbox.tools.segmentation module}
\label{RRtoolbox.tools:rrtoolbox-tools-segmentation-module}\label{RRtoolbox.tools:module-RRtoolbox.tools.segmentation}\index{RRtoolbox.tools.segmentation (module)}\index{find\_optic\_disc() (in module RRtoolbox.tools.segmentation)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.segmentation.find_optic_disc}\pysiglinewithargsret{\code{RRtoolbox.tools.segmentation.}\bfcode{find\_optic\_disc}}{\emph{img}, \emph{P}}{}
find optic disk in image
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{img}} -- BGR image

\item {} 
\textbf{\texttt{P}} -- gray image

\end{itemize}

\item[{Returns}] \leavevmode
optic\_disc, Crs, markers, watershed

\end{description}\end{quote}

\end{fulllineitems}

\index{getBrightAlpha() (in module RRtoolbox.tools.segmentation)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.segmentation.getBrightAlpha}\pysiglinewithargsret{\code{RRtoolbox.tools.segmentation.}\bfcode{getBrightAlpha}}{\emph{backgray}, \emph{foregray}, \emph{window=None}}{}
Get alpha transparency for merging foreground to background gray image according to brightness.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{backgray}} -- background image. (as float)

\item {} 
\textbf{\texttt{foregray}} -- foreground image. (as float)

\item {} 
\textbf{\texttt{window}} -- window used to customizing alfa. It can be a binary or alfa mask, values go from 0 for transparency
to any value where the maximum is visible i.e a window with all the same values does nothing.
A binary mask can be used, where 0 is transparent and 1 is visible.
If not window is given alfa is not altered and the intended alfa is returned.

\end{itemize}

\item[{Returns}] \leavevmode
alfa mask

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_beta\_params() (in module RRtoolbox.tools.segmentation)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.segmentation.get_beta_params}\pysiglinewithargsret{\code{RRtoolbox.tools.segmentation.}\bfcode{get\_beta\_params}}{\emph{P}}{}
automatically find parameters for bright alpha masks.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{P}} -- gray image

\item[{Returns}] \leavevmode
beta1,beta2

\end{description}\end{quote}

\end{fulllineitems}

\index{layeredfloods() (in module RRtoolbox.tools.segmentation)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.segmentation.layeredfloods}\pysiglinewithargsret{\code{RRtoolbox.tools.segmentation.}\bfcode{layeredfloods}}{\emph{img}, \emph{gray=None}, \emph{backmask=None}, \emph{step=1}, \emph{connectivity=4}, \emph{weight=False}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{img}} -- 

\item {} 
\textbf{\texttt{gray}} -- 

\item {} 
\textbf{\texttt{backmask}} -- 

\item {} 
\textbf{\texttt{step}} -- 

\item {} 
\textbf{\texttt{connectivity}} -- 

\item {} 
\textbf{\texttt{weight}} -- 

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{retina\_markers\_thresh() (in module RRtoolbox.tools.segmentation)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.segmentation.retina_markers_thresh}\pysiglinewithargsret{\code{RRtoolbox.tools.segmentation.}\bfcode{retina\_markers\_thresh}}{\emph{P}}{}
Retinal markers thresholds to find background,
retinal area and optic disc with flares based
in the histogram
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{P}} -- gray image

\item[{Returns}] \leavevmode
min,b1,b2,max

\end{description}\end{quote}

\end{fulllineitems}

\index{retinal\_mask() (in module RRtoolbox.tools.segmentation)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.segmentation.retinal_mask}\pysiglinewithargsret{\code{RRtoolbox.tools.segmentation.}\bfcode{retinal\_mask}}{\emph{img}, \emph{biggest=False}, \emph{addalpha=False}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{img}} -- 

\item {} 
\textbf{\texttt{biggest}} -- 

\item {} 
\textbf{\texttt{addalpha}} -- 

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{retinal\_mask\_simple() (in module RRtoolbox.tools.segmentation)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.segmentation.retinal_mask_simple}\pysiglinewithargsret{\code{RRtoolbox.tools.segmentation.}\bfcode{retinal\_mask\_simple}}{\emph{img}, \emph{parameters=(10}, \emph{30}, \emph{None)}}{}
\end{fulllineitems}



\subsubsection{RRtoolbox.tools.selectors module}
\label{RRtoolbox.tools:module-RRtoolbox.tools.selectors}\label{RRtoolbox.tools:rrtoolbox-tools-selectors-module}\index{RRtoolbox.tools.selectors (module)}\index{entropy() (in module RRtoolbox.tools.selectors)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.selectors.entropy}\pysiglinewithargsret{\code{RRtoolbox.tools.selectors.}\bfcode{entropy}}{\emph{imlist}, \emph{loadfunc=None}, \emph{invert=False}}{}
Entropy function modified from:

Yan Liu, Feihong Yu, An automatic image fusion algorithm for unregistered multiply multi-focus images,
Optics Communications, Volume 341, 15 April 2015, Pages 101-113, ISSN 0030-4018,
\href{http://dx.doi.org/10.1016/j.optcom.2014.12.015}{http://dx.doi.org/10.1016/j.optcom.2014.12.015}.
(\href{http://www.sciencedirect.com/science/article/pii/S0030401814011559}{http://www.sciencedirect.com/science/article/pii/S0030401814011559})
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{imlist}} -- list of path to images or arrays

\item[{Returns}] \leavevmode
sortedD,sortedImlist,D,fns

\end{description}\end{quote}
\begin{description}
\item[{where sortedD is the ranking of the Entropy test, D = {[}D0,...,DN{]} D0\textgreater{}DN}] \leavevmode
sortedImlist is fns sorted to match sortedD,
D is the list of the absolute difference between entropy and the root mean square, D = {\color{red}\bfseries{}\textbar{}E-RMS\textbar{}}

\end{description}

\end{fulllineitems}

\index{entropyPlot (class in RRtoolbox.tools.selectors)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.selectors.entropyPlot}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.tools.selectors.}\bfcode{entropyPlot}}{\emph{images}, \emph{win='Entropy tests'}, \emph{func=None}}{}
Bases: {\hyperref[RRtoolbox.lib:RRtoolbox.lib.plotter.plotim]{\emph{\code{RRtoolbox.lib.plotter.plotim}}}}

Plot entropy test
\index{getData() (RRtoolbox.tools.selectors.entropyPlot method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.selectors.entropyPlot.getData}\pysiglinewithargsret{\bfcode{getData}}{\emph{im}}{}
\end{fulllineitems}

\index{getImage() (RRtoolbox.tools.selectors.entropyPlot method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.selectors.entropyPlot.getImage}\pysiglinewithargsret{\bfcode{getImage}}{\emph{im}}{}
\end{fulllineitems}

\index{keyfunc() (RRtoolbox.tools.selectors.entropyPlot method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.selectors.entropyPlot.keyfunc}\pysiglinewithargsret{\bfcode{keyfunc}}{}{}
\end{fulllineitems}

\index{nextim() (RRtoolbox.tools.selectors.entropyPlot method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.selectors.entropyPlot.nextim}\pysiglinewithargsret{\bfcode{nextim}}{}{}
\end{fulllineitems}

\index{previousim() (RRtoolbox.tools.selectors.entropyPlot method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.selectors.entropyPlot.previousim}\pysiglinewithargsret{\bfcode{previousim}}{}{}
\end{fulllineitems}

\index{selectlist() (RRtoolbox.tools.selectors.entropyPlot method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.selectors.entropyPlot.selectlist}\pysiglinewithargsret{\bfcode{selectlist}}{\emph{imlist}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{hist\_comp() (in module RRtoolbox.tools.selectors)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.selectors.hist_comp}\pysiglinewithargsret{\code{RRtoolbox.tools.selectors.}\bfcode{hist\_comp}}{\emph{imlist}, \emph{loadfunc=None}, \emph{method='correlation'}}{}
Histogram comparison
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{imlist}} -- list of path to images or arrays

\item[{Returns}] \leavevmode
comparison

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{RRtoolbox.tools.sticher module}
\label{RRtoolbox.tools:rrtoolbox-tools-sticher-module}\label{RRtoolbox.tools:module-RRtoolbox.tools.sticher}\index{RRtoolbox.tools.sticher (module)}\index{stich() (in module RRtoolbox.tools.sticher)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox.tools:RRtoolbox.tools.sticher.stich}\pysiglinewithargsret{\code{RRtoolbox.tools.sticher.}\bfcode{stich}}{\emph{**opts}}{}
\end{fulllineitems}



\subsubsection{Module contents}
\label{RRtoolbox.tools:module-contents}\label{RRtoolbox.tools:module-RRtoolbox.tools}\index{RRtoolbox.tools (module)}

\section{Submodules}
\label{RRtoolbox:submodules}

\section{RRtoolbox.core module}
\label{RRtoolbox:module-RRtoolbox.core}\label{RRtoolbox:rrtoolbox-core-module}\index{RRtoolbox.core (module)}\index{f() (in module RRtoolbox.core)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox:RRtoolbox.core.f}\pysiglinewithargsret{\code{RRtoolbox.core.}\bfcode{f}}{\emph{*args}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{rrbox (class in RRtoolbox.core)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox:RRtoolbox.core.rrbox}\pysiglinewithargsret{\strong{class }\code{RRtoolbox.core.}\bfcode{rrbox}}{\emph{*args}}{}
Bases: \code{object}
\index{asift() (RRtoolbox.core.rrbox method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox:RRtoolbox.core.rrbox.asift}\pysiglinewithargsret{\bfcode{asift}}{\emph{fn}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{tools() (in module RRtoolbox.core)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox:RRtoolbox.core.tools}\pysiglinewithargsret{\code{RRtoolbox.core.}\bfcode{tools}}{\emph{instance}, \emph{modules}}{}
\end{fulllineitems}

\index{tools2() (in module RRtoolbox.core)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox:RRtoolbox.core.tools2}\pysiglinewithargsret{\code{RRtoolbox.core.}\bfcode{tools2}}{\emph{instance}, \emph{modules}}{}
\end{fulllineitems}



\section{RRtoolbox.run module}
\label{RRtoolbox:module-RRtoolbox.run}\label{RRtoolbox:rrtoolbox-run-module}\index{RRtoolbox.run (module)}

\section{RRtoolbox.shell module}
\label{RRtoolbox:module-RRtoolbox.shell}\label{RRtoolbox:rrtoolbox-shell-module}\index{RRtoolbox.shell (module)}\index{NoParserFound}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox:RRtoolbox.shell.NoParserFound}\pysigline{\strong{exception }\code{RRtoolbox.shell.}\bfcode{NoParserFound}}
Bases: \code{exceptions.Exception}

\end{fulllineitems}

\index{getDocParamLines() (in module RRtoolbox.shell)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox:RRtoolbox.shell.getDocParamLines}\pysiglinewithargsret{\code{RRtoolbox.shell.}\bfcode{getDocParamLines}}{\emph{doc}}{}
gets each parameter line from reStructured doc.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{doc}} -- documentation

\item[{Returns}] \leavevmode
lines

\end{description}\end{quote}

\end{fulllineitems}

\index{getDocParameters() (in module RRtoolbox.shell)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox:RRtoolbox.shell.getDocParameters}\pysiglinewithargsret{\code{RRtoolbox.shell.}\bfcode{getDocParameters}}{\emph{doc}}{}
gets param and comment from reStructured doc.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{doc}} -- documentation

\item[{Returns}] \leavevmode
list of (param,comment) items.

\end{description}\end{quote}

\end{fulllineitems}

\index{shell (class in RRtoolbox.shell)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox:RRtoolbox.shell.shell}\pysigline{\strong{class }\code{RRtoolbox.shell.}\bfcode{shell}}~\index{generateParser() (RRtoolbox.shell.shell method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox:RRtoolbox.shell.shell.generateParser}\pysiglinewithargsret{\bfcode{generateParser}}{\emph{func}}{}
\end{fulllineitems}

\index{getParser() (RRtoolbox.shell.shell method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox:RRtoolbox.shell.shell.getParser}\pysiglinewithargsret{\bfcode{getParser}}{\emph{func}}{}
\end{fulllineitems}

\index{parse() (RRtoolbox.shell.shell method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox:RRtoolbox.shell.shell.parse}\pysiglinewithargsret{\bfcode{parse}}{\emph{func}, \emph{args=None}, \emph{namespace=None}}{}
\end{fulllineitems}

\index{parser\_fastplt() (RRtoolbox.shell.shell method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox:RRtoolbox.shell.shell.parser_fastplt}\pysiglinewithargsret{\bfcode{parser\_fastplt}}{}{}
\end{fulllineitems}

\index{parser\_loadFunc() (RRtoolbox.shell.shell method)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox:RRtoolbox.shell.shell.parser_loadFunc}\pysiglinewithargsret{\bfcode{parser\_loadFunc}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{shell\_processor() (in module RRtoolbox.shell)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox:RRtoolbox.shell.shell_processor}\pysiglinewithargsret{\code{RRtoolbox.shell.}\bfcode{shell\_processor}}{\emph{commands}}{}
\end{fulllineitems}

\index{shell\_processor\_parser() (in module RRtoolbox.shell)}

\begin{fulllineitems}
\phantomsection\label{RRtoolbox:RRtoolbox.shell.shell_processor_parser}\pysiglinewithargsret{\code{RRtoolbox.shell.}\bfcode{shell\_processor\_parser}}{\emph{syslist}, \emph{flags='`}, \emph{longopts=(`feature='}, \emph{`nnn=')}}{}
\end{fulllineitems}



\section{Module contents}
\label{RRtoolbox:module-RRtoolbox}\label{RRtoolbox:module-contents}\index{RRtoolbox (module)}

\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\DUspan{xref,std,std-ref}{genindex}

\item {} 
\DUspan{xref,std,std-ref}{modindex}

\item {} 
\DUspan{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{r}
\item {\texttt{RRtoolbox}}, \pageref{RRtoolbox:module-RRtoolbox}
\item {\texttt{RRtoolbox.core}}, \pageref{RRtoolbox:module-RRtoolbox.core}
\item {\texttt{RRtoolbox.lib}}, \pageref{RRtoolbox.lib:module-RRtoolbox.lib}
\item {\texttt{RRtoolbox.lib.arrayops}}, \pageref{RRtoolbox.lib.arrayops:module-RRtoolbox.lib.arrayops}
\item {\texttt{RRtoolbox.lib.arrayops.basic}}, \pageref{RRtoolbox.lib.arrayops:module-RRtoolbox.lib.arrayops.basic}
\item {\texttt{RRtoolbox.lib.arrayops.convert}}, \pageref{RRtoolbox.lib.arrayops:module-RRtoolbox.lib.arrayops.convert}
\item {\texttt{RRtoolbox.lib.arrayops.filters}}, \pageref{RRtoolbox.lib.arrayops:module-RRtoolbox.lib.arrayops.filters}
\item {\texttt{RRtoolbox.lib.arrayops.mask}}, \pageref{RRtoolbox.lib.arrayops:module-RRtoolbox.lib.arrayops.mask}
\item {\texttt{RRtoolbox.lib.cache}}, \pageref{RRtoolbox.lib:module-RRtoolbox.lib.cache}
\item {\texttt{RRtoolbox.lib.config}}, \pageref{RRtoolbox.lib:module-RRtoolbox.lib.config}
\item {\texttt{RRtoolbox.lib.descriptors}}, \pageref{RRtoolbox.lib:module-RRtoolbox.lib.descriptors}
\item {\texttt{RRtoolbox.lib.directory}}, \pageref{RRtoolbox.lib:module-RRtoolbox.lib.directory}
\item {\texttt{RRtoolbox.lib.inspector}}, \pageref{RRtoolbox.lib:module-RRtoolbox.lib.inspector}
\item {\texttt{RRtoolbox.lib.plotter}}, \pageref{RRtoolbox.lib:module-RRtoolbox.lib.plotter}
\item {\texttt{RRtoolbox.lib.root}}, \pageref{RRtoolbox.lib:module-RRtoolbox.lib.root}
\item {\texttt{RRtoolbox.lib.serverServices}}, \pageref{RRtoolbox.lib:module-RRtoolbox.lib.serverServices}
\item {\texttt{RRtoolbox.lib.session}}, \pageref{RRtoolbox.lib:module-RRtoolbox.lib.session}
\item {\texttt{RRtoolbox.run}}, \pageref{RRtoolbox:module-RRtoolbox.run}
\item {\texttt{RRtoolbox.shell}}, \pageref{RRtoolbox:module-RRtoolbox.shell}
\item {\texttt{RRtoolbox.tools}}, \pageref{RRtoolbox.tools:module-RRtoolbox.tools}
\item {\texttt{RRtoolbox.tools.lens}}, \pageref{RRtoolbox.tools:module-RRtoolbox.tools.lens}
\item {\texttt{RRtoolbox.tools.segmentation}}, \pageref{RRtoolbox.tools:module-RRtoolbox.tools.segmentation}
\item {\texttt{RRtoolbox.tools.selectors}}, \pageref{RRtoolbox.tools:module-RRtoolbox.tools.selectors}
\item {\texttt{RRtoolbox.tools.sticher}}, \pageref{RRtoolbox.tools:module-RRtoolbox.tools.sticher}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
